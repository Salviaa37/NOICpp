# 指针

[从计算机底层认识指针！深入理解C语言指针！_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1o8411T7K5/?vd_source=574e0a38261401341cd391f17b73fdad)

程序中的每一个变量都分配有一个内存位置（一个内存空间），每一个内存位置都有一个地址，这个地址可以使用（&）取地址运算符访问。
下面的实例输出定义的变量地址：
```cpp
#include <iostream>
 
using namespace std;
 
int main ()
{
   int  var1;
   char var2[10];
 
   cout << "var1 变量的地址： ";
   cout << &var1 << endl;
 
   cout << "var2 变量的地址： ";
   cout << &var2 << endl;
 
   return 0;
}
```
运行结果如下：
```cpp
var1 变量的地址： 0x5ffeb0
var2 变量的地址： 0x5ffeb6
```
通过对一个变量使用`&`取地址运算符，可以获取这个变量占用的内存位置的地址。

## 指针的含义
那么什么是指针？指针（pointer）也是一种数据类型，但是指针存储的是内存空间的地址。
在计算机里，内存（主存，Memory）中的每个存储单元都有一个唯一的地址，指针变量所保存的就是这个地址。
通过指针，你能够直接访问和操作该地址处的内存数据。
### 声明一个指针变量
要声明一个指针变量，需要在变量名前面添加 `*`号
```cpp
type *var-name;
```
在这里，**type** 是指针的基类型，它必须是一个有效的 C++ 数据类型，**var-name** 是指针变量的名称。
用来声明指针的星号 * 与乘法中使用的星号是相同的。但是在这个语句中，星号是用来指定一个变量是指针。
以下是有效的指针声明：
```cpp
int    *ip;    /* 一个整型的指针 */
double *dp;    /* 一个 double 型的指针 */
float  *fp;    /* 一个浮点型的指针 */
char   *ch;    /* 一个字符型的指针 */

```
## 指针的使用

在使用指针之前要先定义指针，对指针变量的类型说明，一般形式为：

```CPP
typedef *var_name;
```

其中，`*`表示这是一个指针变量，var_name即为定义的指针变量名，typedef代表类型说明符表示该指针变量所指向的变量的数据类型。
如下例子：
```cpp
int a = 3;
int *p = &a;
```
定义一个整型变量a，值为3。内存中有一块内存空间是放a的值，对a的存取操作就是直接到这个内存空间存取。
内存空间的位置叫地址，定义一个指针变量p，p存储一个内存地址。
存放3的地址可以用取地址操作符“&.”对a运算得到：&a。
把a变量的内存空间地址(比如：XXX)给了p。显然，直接对p存取，操作的是地址。

通过这个地址间接地操作，才是整数3.如图8-1。P的间接操作要使用指针操作符`*`
即`*p`的值才是3。


一般的，我们可以这样看指针(`int *p`)与变量(`int a`)的对应关系：

| 指针变量     | 变量    | 运算符             |
| -------- | ----- | --------------- |
| p        | &a    | & ：取变量a的地址      |
| `*p`     | a     | * ：取p这个地址存储的值   |
| `*p = 3` | a = 3 | * ：给p地址存储的变量赋值3 |
指针也可以指向指针。


#### 指针变量的初始化
指针也是一种变量，使用指针变量前不仅要定义说明，而且必须被赋予具体的值，未经赋值的指针变量不能使用。

有如下的几种方式初始化一个指针。
1 初始化为空指针，这种情况下指针不存储任何内存地址。
`int *p = nullptr;` 

2 初始化为某个变量的内存地址。
`int a = 0; int *p = &a;`

3 开辟一块新的内存空间，让p指向这块内存空间。
`int *p = new(int);`

并且，由于指针变量存储内存地址，，否则会误操作其他内存空间，这种情况称为”越界访问“。

#### 空指针
空指针就是不指向任何内存位置的指针。
空指针对应的内存空间并没有存储一个内存地址，而是使用关键字`nullptr`来表示它是空指针。


> [!note] nullptr和NULL，谁是空指针？
> ⚠️空指针应该用`nullptr`来表示，不要使用`NULL`关键字来置空一个指针变量。
> 执行下面的代码
> 
> ```cpp
> void func(int);
> void func(char*);
> 
> func(NULL);  // 可能调用func(int)，不符合预期
> ```
> 这里会出现调用函数的歧义。`NULL`关键字的本质一个宏定义的整形数字`0`，在这里既可以代表`char*`类型的空指针，也可以代表整数0。因此在调用func函数的时候，编译器不能确定应该调用哪一个func。
> 
> 为了避免这样的情况，C++11版本起引入了新的关键字`nullptr`，是`std::nullptr_t`类型的常量，是一个明确的指针类型，表示空指针。
> ```cpp
> func(nullptr);  // 明确调用func(char*)
> ```



## 指针的运算

#### 指针的算术运算
指针是一个用数值表示的地址。因此，可以对指针执行算术运算。可以对指针进行四种算术运算：`++、--、+、-`。

假设 `ptr` 是一个指向地址 1000 的整型指针，是一个 32 位的整数，让我们对该指针执行下列的算术运算：
```cpp
ptr++;
```
执行 ptr++ 后，指针 ptr 会向前移动 4 个字节，指向下一个整型元素的地址。这是由于指针算术运算会根据指针的类型和大小来决定移动的距离。在这种情况下，由于是一个 32 位整数指针，每个整数占据 4 个字节，因此 ptr++ 会将指针 ptr 向前移动 4 个字节，指向下一个整型元素的地址。

如果 **ptr** 指向一个地址为 1000 的字符，执行 ptr++ 指针 ptr 的值会增加，指向下一个字符元素的地址，由于 ptr 是一个字符指针，每个字符占据 1 个字节，因此 ptr++ 会将 ptr 的值增加 1，执行后 ptr 指向地址 1001。

指针算术运算的详细解析：

- 加法运算：可以对指针进行加法运算。当一个指针p加上一个整数n时，结果是指针p向前移动n个元素的大小。例如，如果p是一个int类型的指针，每个int占4个字节，那么p + 1将指向p所指向的下一个int元素。
    
- 减法运算：可以对指针进行减法运算。当一个指针p减去一个整数n时，结果是指针p向后移动n个元素的大小。例如，如果p是一个int类型的指针，每个int占4个字节，那么p - 1将指向p所指向的前一个int元素。
    
- 指针与指针之间的减法运算：可以计算两个指针之间的距离。当从一个指针p减去另一个指针q时，结果是两个指针之间的元素个数。例如，如果p和q是两个int类型的指针，每个int占4个字节，那么p - q将得到两个指针之间的元素个数。
    
- 指针与整数之间的比较运算：可以将指针与整数进行比较运算。可以使用关系运算符（如<、>、<=、>=）对指针和整数进行比较。这种比较通常用于判断指针是否指向某个有效的内存位置。


#### 指针的比较

在C++中，指针的比较操作可以用于确定两个指针是否指向相同的位置、一个指针是否指向的位置在另一个指针之前或之后等。指针的比较主要包括以下几种：

- **相等性
- **关系比较** (`<`, `<=`, `>`, `>=`)

##### 相等性比较

相等性比较用于检查两个指针是否指向相同的位置。

实例
```cpp
#include <iostream>  
  
int main() {  
    int a = 10;  
    int b = 20;  
    int* ptr1 = &a;  
    int* ptr2 = &a;  
    int* ptr3 = &b;  
  
    // 比较指针是否相等  
    if (ptr1 == ptr2) {  
        std::cout << "ptr1 和 ptr2 指向相同的位置" << std::endl;  
    } else {  
        std::cout << "ptr1 和 ptr2 指向不同的位置" << std::endl;  
    }  
  
    if (ptr1 != ptr3) {  
        std::cout << "ptr1 和 ptr3 指向不同的位置" << std::endl;  
    } else {  
        std::cout << "ptr1 和 ptr3 指向相同的位置" << std::endl;  
    }  
  
    return 0;  
}  
```
当上面的代码被编译和执行时，它会产生下列结果：

```
ptr1 和 ptr2 指向相同的位置
ptr1 和 ptr3 指向不同的位置
```

##### 关系比较

关系比较用于确定一个指针是否指向的位置在另一个指针之前或之后。这通常在指针指向同一个数组的元素时有意义。
```cpp
int a[3] = {1,2,3};
int *p = &a; //0x1034
*p ++; // 0x1038

```
实例
```cpp
#include <iostream>  
  
int main() {  
    int arr[] = {10, 20, 30, 40, 50};  
    int* ptr1 = &arr[1]; // 指向数组的第二个元素  
    int* ptr2 = &arr[3]; // 指向数组的第四个元素  
  
    // 比较指针的相对位置  
    if (ptr1 < ptr2) {  
        std::cout << "ptr1 指向的元素在 ptr2 指向的元素之前" << std::endl;  
    } else {  
        std::cout << "ptr1 指向的元素不在 ptr2 指向的元素之前" << std::endl;  
    }  
  
    if (ptr2 > ptr1) {  
        std::cout << "ptr2 指向的元素在 ptr1 指向的元素之后" << std::endl;  
    } else {  
        std::cout << "ptr2 指向的元素不在 ptr1 指向的元素之后" << std::endl;  
    }  
  
    return 0;  
}  
```

当上面的代码被编译和执行时，它会产生下列结果：
```
ptr1 指向的元素在 ptr2 指向的元素之前
ptr2 指向的元素在 ptr1 指向的元素之后
```

##### 注意事项

- **同一数组范围内的比较**： 关系比较（如 `<`, `>`, `<=`, `>=`）在同一数组的元素之间进行是有意义的。如果指针不属于同一个数组，关系比较的结果是未定义的。
- **指针为空**： 在比较指针之前，确保指针不是空指针（`nullptr`），否则可能会导致未定义行为。

## 指针与数组

##### 指针访问数组

指针和数组是密切相关的。事实上，指针和数组在很多情况下是可以互换的。例如，一个指向数组开头的指针，可以通过使用指针的算术运算或数组索引来访问数组。请看下面的程序：

variable 变量
```cpp
#include <iostream>
 
using namespace std;
const int MAX = 3;
 
int main ()
{
   int  var[MAX] = {10, 100, 200};
   int  *ptr;
 
   // 指针中的数组地址
   ptr = var;
   for (int i = 0; i < MAX; i++)
   {
      cout << "var[" << i << "]的内存地址为 ";
      cout << ptr << endl;
 
      cout << "var[" << i << "] 的值为 ";
      cout << *ptr << endl;
 
      // 移动到下一个位置
      ptr++;
   }
   return 0;
}
```
当上面的代码被编译和执行时，它会产生下列结果：
```
var[0]的内存地址为 0x7fff59707adc
var[0] 的值为 10
var[1]的内存地址为 0x7fff59707ae0
var[1] 的值为 100
var[2]的内存地址为 0x7fff59707ae4
var[2] 的值为 200
```

然而，指针和数组并不是完全互换的。例如，请看下面的程序：
```cpp
#include <iostream>
using namespace std;
const int MAX = 3;
 
int main ()
{
   int  var[MAX] = {10, 100, 200};
 
   for (int i = 0; i < MAX; i++)
   {
      *var = i;    // 这是正确的语法
      var++;       // 这是不正确的
   }
   return 0;
}
```
把指针运算符 `*` 应用到 `var `上是完全可以的，但修改 `var` 的值是非法的。这是因为 `var` 是一个==指向数组开头的常量==，不能作为左值被修改。

由于一个数组名对应一个指针常量，只要不改变数组的值，仍然可以用指针形式的表达式。例如，下面是一个有效的语句，把 `var[2] `赋值为 500：
```cpp
*(var + 2) = 500;
```
上面的语句是有效的，且能成功编译，因为 var 未改变。
##### 指针与动态数组
指针可以动态申请内存空间，如果一次申请多个变量空间，系统给的地址是连续的，就可以当成数组使用，这就是一种动态数组。
使用new关键字开辟新的内存空间，长度为n+1。
```cpp
#include <iostream>
using namespace std;

int main(){
	int n = 0;
	cin << n;
	int *a = new int[n+1];
	return 0;
}
```

#### 指针与字符串



## 指针与结构体、类
通过指针可以访问结构体和类的成员，但是访问运算符与直接访问不同。
#### 直接访问
```cpp
// 学生结构体
struct stu{
	char name[100]; //姓名
	double score; //成绩
};
// 创建一个结构体，名称叫“小明”
struct stu xiaoming;
// 通过.运算符访问成员
xiaoming.name = "xiaoming";

```
#### 指针访问
```cpp
// 学生结构体
struct stu{
	char name[100]; //姓名
	double score; //成绩
};
// 创建一个结构体，名称叫“小明”
struct stu xiaoming;
// 指针通过->运算符访问成员
stu *stu1 = &s;
//在结构体指针中，不能用.来指向结构体成员变量(stu 是地址) 
cout<<stu1->name<<" "<<stu1->score<<endl;

//或通过取值运算符和.运算符访问(*stu)是结构体
cout<<(*stu1).name<<" "<<(*stu1).score<<endl; 
```


#### 示例代码
```cpp
#include <bits/stdc++.h>
using namespace std;
struct stu{
	char name[100];
	double score;
};
int main(){
	//定义结构体变量
	struct stu s;
	strcpy(s.name,"ZhangSan");
	s.score = 99.99;
	//输出结构体
	cout<<s.name<<" "<<s.score<<endl; 
	
	//定义指针，指向结构体 struct stu *stu = &s;//struct 可以省略
	stu *stu1 = &s;
	//在结构体指针中，不能用.来指向结构体成员变量(stu 是地址) 
	cout<<stu1->name<<" "<<stu1->score<<endl;
	
	//(*stu)是结构体
	cout<<(*stu1).name<<" "<<(*stu1).score<<endl; 
	
	//new 结构体对象，直接赋值给一个指针
	stu *stu2 = new stu;
	strcpy(stu2->name,"ZhangSan");
	stu2->score = 99.8;
	cout<<stu2->name<<" "<<stu2->score<<endl;
	delete stu2;//释放内存
	//malloc 结构体对象，直接赋值给一个指针
	stu *stu3 = NULL;
	stu3 = (stu*)malloc(sizeof(stu));
	strcpy(stu3->name,"WangWu");
	stu3->score = 98;
	cout<<stu3->name<<" "<<stu3->score<<endl;
	free(stu3);//释放内存
	return 0;
}
```


## 指针与函数

### 指针作为函数参数

指针变量也是变量，C++允许指针变量作为函数参数传递。

可以理解为函数的参数是一个内存地址，函数就可以==对这个内存地址处存储的值进行操作==。
#### 直接修改内存空间内容
例如下面的程序`swap()`实现了交换两个整数的值。
```cpp
void swap(int *x, int *y) {
    int temp = *x;
    // 对内存地址处具体的内存空间做修改
    *x = *y;
    *y = temp;
}

int main() {
    int a = 5, b = 10;
    swap(&a, &b);
    cout << a << " " << b;
    return 0;
}
```
运行结果如下：
```cpp
10 5
```
在这个过程中，我们先将a和b的地址传给函数，然后在函数中通过地址找到放置a和b变量的值的内存空间，并且对内存空间进行修改。当退出函数时，a和b的值就已经交换了。

如果我们没有让地址作为参数
```cpp
void swap(int x, int y) {
    int temp = x;
    x = y;
    y = temp;
}

int main() {
    int a = 5, b = 10;
    swap(a, b);
    cout << a << " " << b;
    return 0;
}
```
运行结果：
```cpp
5 10
```
虽然我们调用了`swap(a,b);`，然而这个函数没有起作用，没有将a和b的值互换。
为什么呢？因为这里在传入变量a和b的时候，是将a和b的值==拷贝一份给函数swap()==。既然是拷贝来的的值，这里接下来的操作就完全与a和b无关了，函数将变量x和y的值互换，然后退出函数。

由于没有像上面例子那样传入指针对具体的内存空间做操作，所以无法对变量进行修改。

#### 数组名作为参数
上节提到，数组的变量名本质上是一个常量指针，因此能接受指针作为参数的函数，也可以接受数组作为函数参数。
```cpp
#include <iostream>
using namespace std;
 
// 函数声明
double getAverage(int *arr, int size);
 
int main ()
{
   // 带有 5 个元素的整型数组
   int balance[5] = {1000, 2, 3, 17, 50};
   double avg;
 
   // 传递一个指向数组的指针作为参数
   avg = getAverage( balance, 5 ) ;
 
   // 输出返回值
   cout << "Average value is: " << avg << endl; 
    
   return 0;
}
 
double getAverage(int *arr, int size)
{
  int    i, sum = 0;       
  double avg;          
 
  for (i = 0; i < size; ++i)
  {
    sum += arr[i];
   }
 
  avg = double(sum) / size;
 
  return avg;
}
```
当上面的代码被编译和执行时，它会产生下列结果：
```
Average value is: 214.4
```

### 从函数返回指针

C++ 不允许返回一个完整的数组作为函数的参数。但是，您可以通过指定不带索引的数组名来返回一个指向数组的指针。

如果您想要从函数返回一个一维数组，您必须声明一个返回指针的函数，如下：
```cpp
int * myFunction(){
	/*  */
}
```

另外，C++ ==不支持函数返回局部变量的地址==，除非定义局部变量为 **static** 变量。
就是说，函数内定义的一个局部变量的地址，比如一个函数内开辟的数组，无法作为返回值。因为局部变量的作用域仅限于函数范围，生存期只在函数运行时，函数运行结束，局部变量的地址就会被注销。引用也是同理。

现在，让我们来看下面的函数，它会生成 10 个随机数，并使用数组来返回它们，具体如下
```cpp
#include <iostream>
#include <cstdlib>
#include <ctime>

using namespace std;

// 要生成和返回随机数的函数
int * getRandom( )
{
  static int  r[10];

  // 设置种子
  srand( (unsigned)time( NULL ) );
  for (int i = 0; i < 10; ++i)
  {
    r[i] = rand();
    cout << r[i] << endl;
  }

  return r;
}

// 要调用上面定义函数的主函数
int main ()
{
   // 一个指向整数的指针
   int *p;

   p = getRandom();
   for ( int i = 0; i < 10; i++ )
   {
       cout << "*(p + " << i << ") : ";
       cout << *(p + i) << endl;
   }

   return 0;
}
```

代码返回值如下：
```cpp
624723190
1468735695
807113585
976495677
613357504
1377296355
1530315259
1778906708
1820354158
667126415
*(p + 0) : 624723190
*(p + 1) : 1468735695
*(p + 2) : 807113585
*(p + 3) : 976495677
*(p + 4) : 613357504
*(p + 5) : 1377296355
*(p + 6) : 1530315259
*(p + 7) : 1778906708
*(p + 8) : 1820354158
*(p + 9) : 667126415
```


# 引用

## 引用与函数

### 引用作为返回值
通过使用引用来替代指针，会使 C++ 程序更容易阅读和维护。C++ 函数可以返回一个引用，方式与返回一个指针类似。

作用域问题：
当返回一个引用时，要注意被引用的对象不能超出作用域。所以返回一个对局部变量的引用是不合法的，但是，可以返回一个对静态变量的引用，例如：
```cpp
int& func() {
   int q;
   //! return q; // 在编译时发生错误
   static int x;
   return x;     // 安全，x 在函数作用域外依然是有效的
}
```



当函数返回一个引用时，则返回一个指向返回值的隐式指针。这样，函数就可以放在赋值语句的左边（作为左值）。可以通过该引用修改原变量的值。例如，请看下面这个简单的程序：
```cpp
#include <iostream>
using namespace std;

//全局数组vals
double vals[] = {10.1, 12.6, 33.1, 24.1, 50.0}; 

double& setValues( int i )
{
  return vals[i];   // 返回第 i 个元素的引用
}

// 要调用上面定义函数的主函数
int main (){

   cout << "改变前的值" << endl;
   for ( int i = 0; i < 5; i++ ){
       cout << "vals[" << i << "] = ";
       cout << vals[i] << endl;
   }

   setValues(1) = 20.23; // 改变第 2 个元素
   setValues(3) = 70.8;  // 改变第 4 个元素

   cout << "改变后的值" << endl;
   for ( int i = 0; i < 5; i++ ){
       cout << "vals[" << i << "] = ";
       cout << vals[i] << endl;
   }
   return 0;
}
```
代码结果如下：
```plain
改变前的值
vals[0] = 10.1
vals[1] = 12.6
vals[2] = 33.1
vals[3] = 24.1
vals[4] = 50
改变后的值
vals[0] = 10.1
vals[1] = 20.23
vals[2] = 33.1
vals[3] = 70.8
vals[4] = 50
```

