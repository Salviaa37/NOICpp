### 图的定义
城市道路网、食物网；

节点(vertex)用边(edge)连起来就叫作图，严格意义上讲，图是一种数据结构，定义为`graph=(V,E)`。`V`是一个非空有限集合，代表顶点(节点)，`E`代表边的集合。

树是一种特殊的图
### 图的相关概念
#### 图的分类
1.有向图（Undirected Graph）：图的边有方向，只能按箭头方向从一点到另一点，(a)就是一个有向图。


2.无向图（Directed Graph）：图的边没有方向，可以双向，(b)就是一个无向图。
![[Pasted image 20250624230209.png]]

#### 节点与边
3.节点的度（degree）：无向图中与节点相连的边的数目，称为节点的度。有向图中节点入度与出度的和称为节点的度。
4.节点的入度（In-degree）：在有向图中，以这个节点为终点的有向边的数目。
5.节点的出度：在有向图中，以这个节点为起点的有向边的数目。

6.权值（Weight）：边的“费用”,可以形象地理解为边的长度。形象的说，就像从一个地方到另一个地方有几条路可以走，每条路要花费多少时间。

#### 图的 属性
连通（Connection）：如果图中节点`U、V`之间存在一条从U通过若干条边、点到达V的通路，则称`U、V`是连通的。
连通图（Connected Graph）：从图中任意一个节点我们可以访问图中的所有其他节点的图形称为联通图。

回路/环（Loop/Cycle）：起点和终点相同的路径，称为回路，或“环”。

子图（Sub-Graph）：如果有两个图，其中一个A图属于另外一个B图。则图A为图B的子图。

完全图（Complete Graph）：一个n阶的完全无向图含有`n*(n-1)/2`条边，一个`n`阶的完全有向图含有`n*(n-1)`条边。
- 稠密图（Dense Graph）：一个边数接近完全图的图。
- 稀疏图（Sparse Graph）：一个边数远远少于完全图的图。

强连通分量：有向图中任意两点都连通的最大子图。下图中，1-2-5构成一个强连通分量。特殊地，单个点也算一个强连通分量，所
以右图有三个强连通分量：1-2-5,4,3。
![[Pasted image 20250627133028.png]]


### 图的表示与存储

#### 邻接矩阵表示法
图的邻接矩阵存储方式是用一个二维数组（称为邻接矩阵）存储图中边的信息，它适用于==稠密图==。

定义 一个二位数`int g[101][101];`，其中`g[i][j]`表示从点i到点j的边的权值，定义如下：
$$ 
G[i][j] = 
\begin{cases} 
1 \text{ 或权值} & \text{当 } v_i \text{ 与 } v_j \text{ 之间有边或弧时} \\ 
0 \text{ 或 } \infty & \text{当 } v_i \text{ 与 } v_j \text{ 之间无边或弧时} 
\end{cases}
$$

例如，
![[Pasted image 20250624234639.png]]
上图中的3个图对应的邻接矩阵分别如下：
![[Pasted image 20250627133943.png]]

邻接矩阵的代码：
```cpp
#include<iostream>
using namespace std;

int e,n;
double g[101][101];
double w;

int main(){
	int i,j;
	for(i=1;i<=n;i++){
		for(j=1;j<=n;j++){
			g[i][j]=0x7ffff;
		// 初始化，对于不带权的图g[i][j]=0,表示没有边连通。
		// 这里用0x7fffff代替无穷大
		}
	}
	int edge,weight;
	cin>>edge;
	for(int k=1;k<=edge;k++){
		cin>>i>>j>>weight; //读入两个顶点序号及权值
		g[i][j]=weight; //对于不带权的图g[i][j]=1
		g[j][i]=weight; //无向图的对称性，如果是有向图则不要有这句
	}
	return0;
}
```


#### 邻接表表示法
还记得指针数组吗？指针数组结合了数组和指针。
邻接表是一种将数组与链表相结合的存储方法，其具体实现为：将图中顶点用一个==一维数组==存储，每个顶点`Vi`的所有邻接点用==一个单链表来存储==，链表中存放与当前结点相邻的结点在数组中的下标，适用于稀疏图。

##### 无向图
![[Pasted image 20250624235240.png]]
无向图第`i`个链表的边结点数目正好是第`i`个顶点的度。
对于具有`n`个结点、`e`条边的无向图，邻接表中数组有`n`个顶点结点、链表有`2e`个边结点。

##### 有向图
![[Pasted image 20250624235428.png]]
有向图第`i`个链表的边结点数目正好是第`i`个顶点的出度。
对于具有`n`个结点、`e`条边的有向图，邻接表中数组有`n`个顶点结点、链表有`e`个边结点。

### 图的遍历

#### 深度优先遍历
深度优先遍历是从图中一个点A出发，将这个点标为已访问`visited [i]=true`,然后再访问所有与之相连且未被访问过的点。当A的所有邻接点都被访问过后，退回到A的上一个点(假设是B),再从B的另一个未被访问的邻接点出发，继续遍历。
![[Pasted image 20250627133122.png]]
例如，对上面的无向图做深度优先遍历，假定先从节点1出发，程序按
如下顺序遍历：
1. 1→2→5,然后退回到2,退回到1。
2. 从1开始再访问未被访问过的点3,3没有未访问的邻接点，退回1。
3. 再从1开始访问未被访问过的点4,再退回1。
4. 起点1的所有邻接点都已访问，遍历结束。


#### 广度优先遍历（Board First Travesal）

广度优先遍历类似于树的层次遍历过程。

以一个无向图为例，介绍一下广度优先搜索的算法步骤。
1. 将起始节点 u 放入队列中，并标记为已访问。
2. 从队列中取出一个节点，访问它并将其所有的未访问邻接节点 v 放入队列中。
3. 标记已访问的节点 v，以避免重复访问。
4. 重复步骤 2∼3，直到队列为空或找到目标节点。


广度优先遍历并不常用，从编程复杂度的角度考虑，通常采用的是深度优先遍历。

## 图的最小生成树
### Prim算法

### Kruskal算法


## 🆕图的一笔画问题
[【视频讲解】七桥问题 一笔画问题](https://www.bilibili.com/video/BV1UW411K7mT/?vd_source=574e0a38261401341cd391f17b73fdad)

一笔画问题（Eulerian Graph）是图论中一个著名的问题。一笔画问题起源于柯尼斯堡七桥问题。数学家欧拉在他1736年发表的论文《柯尼斯堡的七桥》中解决了七桥问题，并且提出了一笔画定理来解决一笔画问题。

如果一个==无向连通图==存在一笔画，则一笔画的路径叫作==欧拉路（Euler Path）==，如果最后又回到起点，那这个路径叫作==欧拉回路（Euler Loop）==。

用图论的术语来说，就是判断这个图是否是一个能够遍历完所有的边而没有重复（连通无向图有欧拉路径）。这样的图现称为欧拉图。这时遍历的路径称作欧拉路径（一个环或者一条链），如果路径闭合（一个圈），则称为欧拉回路。


奇点：奇点是指跟==这个点相连的边数目有奇数个的点==。

### 一笔画定理
对于能够一笔画的图，欧拉提出了以下两个定理。

定理1：存在欧拉路的条件，图是连通的，有且只有2个奇点。

定理2：存在欧拉回路的条件，图是连通的，有0个奇点。

两个定理合起来可以写作“存在欧拉路的充要条件是图中奇顶点数目不多于2个”，这是因为奇顶点数目不可能是1个。实际上，连通无向图中，奇顶点的数目总是偶数。

定理的正确性是显而易见的，既然每条边都要经过一次，那么对于欧拉路，除了起点和终点外，每个点如果进入了一次，一定要出去一次，显然是偶点。对于欧拉回路，每个点进入和出去次数一定都是相等的，显然没有奇点。


### 代码实现
求欧拉路的算法很简单，使用深度优先遍历即可。

根据一笔画的两个定理，如果寻找欧拉回路，对任意一个点执行深度优先遍历；找欧拉路，则对一个奇点执行深度优先搜索，时间复杂度为O(m+n)，m为边数，n是点数。

## 🆕拓扑排序
拓扑排序（Topological Sorting）解决的是一系列活动执行顺序的问题。
[【视频讲解】拓扑排序教程](https://www.bilibili.com/video/BV1Vh56zsE37/?vd_source=574e0a38261401341cd391f17b73fdad)
### AOV网、有向无环图
![[Pasted image 20250627211323.png]]
图所示为制造一个产品的顺序图。制造该产品需要3个环节：
- 第一个环节获得原材料，
- 第二个环节生产出3个部件，
- 第三个环节由3个部件组装成成品。
显然，在原材料没有准备好之前不能生产部件，在3个部件全部被生产
出来之前不能组装成成品。
那么这样一个工程的各个活动之间的先后次序关系就可以用一个有向图来表示，称之为==AOV网（Activity On Vertex network）==，即活动在顶点上的网。


AOV网是一种可以形象地反映出整个过程中各个活动之间的先后关
系的有向图。
比如穿衣服去上学的过程：
![[Pasted image 20250628170130.png]]
度为0的节点意味着他们没有先后次序关系，先穿内衣先穿内裤纯属个人习惯，因此排序方式有很多种，见下图。
![[Pasted image 20250628170208.png]]

通过观察我们可以发现，AOV网是一种以顶点表示活动、以边表示活动的先后次序的**有向无环图**（DAG，Directed Acyclic Graph）。
因为如果有环就意味着，一项活动以自己的完成为前提，这毫无疑问违背了实际。你不能说，你早上吃早饭之前要吃完早饭，或者你穿外套的前提是穿上了外套，这很奇怪对吧。

### 拓扑排序的步骤
对一个有向无环图进行拓扑排序，是指对图中的所有节点进行线性排序，使得对于图中的每条有向边 `u--->v`，顶点 `u` 在拓扑排序序列中都排在 `v`之前。

> [!note]
> 拓扑排序仅仅针对有向无环图的的节点排序，对其他图无效。
> 
> 拓扑排序是一种依赖性问题，其中一个节点代表活动的完成取决于其他几个节点代表活动的完成，而不具有依赖关系的节点顺序可能会有所不同。


在一个有向图中找到一个拓扑排序序列的过程如下：
1)从有向图中选择一个没有前驱(入度为0)的顶点输出。
2)删除1)中的顶点，并且删除从该顶点发出的全部边。
3)重复上述两步，直到剩余的图中不存在没有前驱的顶点为止。
![[Pasted image 20250627214147.png]]
以这个图为例：
图` V = 6, edges = [[2, 3], [3, 1], [4, 0], [4, 1], [5, 0], [5, 2]]`
拓扑排序结果是： 5 4 2 3 1 0

注意：
- 拓扑排序中的第一个顶点始终是入度为 0 的顶点 (没有入边的顶点)。下图的拓扑排序为 “542310”。
- 一个图可以有多个拓扑排序。该图的另一个拓扑排序为 “452310”。