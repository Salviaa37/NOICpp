

# 大数加法的编程实现

大数加法是指对超过编程语言基本数据类型表示范围的整数进行加法运算。由于普通整数类型(如int, long)有大小限制，我们需要用字符串或数组来表示大数并进行逐位相加。

# 高精度四则运算

高精度四则运算是指处理超出基本数据类型表示范围的大数运算方法。下面我将详细讲解如何实现高精度运算。

高精度算法是一种模拟法，本质上是对手工计算加减乘除的模拟。

## 高精度运算的必要性

我们注意到，在大多数编程语言中，基本数据类型（如int, long等）有固定的位数限制：

- 32位int（int32，long）最大约21亿，也就是$21*10^8$
- 64位long long（int64）最大约$9×10^{18}$

但是很多情况下计算的数字是超出这个限制的，当数字超过这些限制时，就需要使用高精度运算。

## 表示方法

通常用字符串或数组来表示大数：

1. ​**​字符串表示法​**​：如`"12345678901234567890"`
2. ​**​数组表示法​**​：每位数字单独存储，如`[1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0]`

根据具体的题目要求，选择不同的方式表示大数，这里我们选用数组（C++ vector；Python list）

```cpp
// 高精度整数结构体
struct BigInt {
    std::vector<int> digits;  // 每位存一位数字，低位在前（例如123存为{3,2,1}）
};
// 字符串转 BigInt
BigInt stringToBigInt(const std::string& num) {
    BigInt res;
    for (int i = num.size() - 1; i >= 0; i--) {
        res.digits.push_back(num[i] - '0');
    }
    return res;
}

```
## 四则运算实现

### 1. 高精度加法

​**​算法步骤​**​：

1. 对齐两个数的位数（前面补零）
2. 从最低位开始逐位相加
3. 处理进位
4. 最后反转结果字符串(如果需要)

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

BigInt add(const BigInt& a, const BigInt& b) {
    BigInt res;
    int carry = 0;
    for (int i = 0; i < max(a.digits.size(), b.digits.size()) || carry; ++i) {
		// 对齐位数，使用三元运算符
        int x = (i < a.digits.size() ? a.digits[i] : 0);
        int y = (i < b.digits.size() ? b.digits[i] : 0);
        // 当前位的加和，记得加上进位
        int sum = x + y + carry;
        // 当前位
        res.digits.push_back(sum % 10);
        // 保存向下一位的进位
        carry = sum / 10;
    }
    return res;
}

```

### 2. 高精度减法

​**​算法步骤​**​：

1. 比较两数大小，确保大数减小数
2. 对齐位数
3. 从最低位开始逐位相减
4. 处理借位

```cpp
BigInt subtract(const BigInt& a, const BigInt& b) {
    BigInt res;
    int borrow = 0;
    for (size_t i = 0; i < a.digits.size(); ++i) {
        int x = a.digits[i] - (i < b.digits.size() ? b.digits[i] : 0) - borrow;
        if (x < 0) {
            x += 10;
            borrow = 1;
        } else {
            borrow = 0;
        }
        res.digits.push_back(x);
    }
    // 去除前导 0
    while (res.digits.size() > 1 && res.digits.back() == 0)
        res.digits.pop_back();
    return res;
}

```

### 3. 高精度乘法

​**​算法步骤​**​：

1. 初始化结果数组（长度为len(a)+len(b))
2. 双重循环，逐位相乘
3. 累加到正确位置
4. 处理进位

```cpp
// 定义 BigInt：用 vector<int> 表示大整数，低位在前
struct BigInt {
    std::vector<int> digits;
};

// 高精度乘法：返回 a × b
BigInt multiply(const BigInt& a, const BigInt& b) {
    BigInt res;

    // 初始化结果数组长度为 a.size + b.size
    // 最多不会超过这个长度（比如99×99=9801，占4位）
    res.digits.resize(a.digits.size() + b.digits.size(), 0);

    // 双重循环实现竖式乘法
    for (size_t i = 0; i < a.digits.size(); ++i) {
        for (size_t j = 0; j < b.digits.size(); ++j) {
            // 累加每一位的乘积到对应的位置（低位相加）
            res.digits[i + j] += a.digits[i] * b.digits[j];
        }
    }

    // 处理进位：从低位往高位遍历
    int carry = 0;
    for (size_t i = 0; i < res.digits.size(); ++i) {
        res.digits[i] += carry;            // 加上上一步的进位
        carry = res.digits[i] / 10;        // 计算当前位产生的进位
        res.digits[i] %= 10;               // 当前位只保留个位
    }
	// 
    // 移除高位多余的前导 0（但至少保留一位0）,因为resize会多出来0
    while (res.digits.size() > 1 && res.digits.back() == 0) {
        res.digits.pop_back();
    }
    return res;
}

```

### 4. 高精度除法

除法是最复杂的运算，通常实现为：

1. 高精度除以低精度（除数在基本数据类型范围内）
2. 高精度除以高精度（更复杂）

​**​高精度除以低精度示例​**​：

算法步骤：
1. 初始化结果数组（长度为被除数长度）。
2. 从高位到低位进行除法（模拟手算）。
	1. 1. 初始化一个余数 `remainder = 0`
	2. 结果商初始化为与 A 相同长度的数组（或者 `vector<int>`）
	3. 从最高位（`a.digits.size()-1`）到最低位（0）：
	    a. 拼接当前位：`current = remainder * 10 + a.digits[i]`
	    b. 商的当前位 = `current / b`
	    c. 更新 `remainder = current % b`
3. 去除商中的前导零（高位0）
4. 返回结果（商 + 余数）
```cpp
// 高精度整数结构体
struct BigInt {
    std::vector<int> digits; // 存储大整数，每位一个数字，低位在前
};

// 高精度除法：BigInt 除以 int，返回 商(BigInt) 和 余数(int)
std::pair<BigInt, int> divide(const BigInt& a, int b) {
    BigInt quotient;                         // 商的结果
    quotient.digits.resize(a.digits.size()); // 初始与 a 位数一样

    int remainder = 0;  // 当前余数，初始为 0

    // 从高位（a.digits.size()-1）向低位遍历
    for (int i = a.digits.size() - 1; i >= 0; --i) {
        int current = remainder * 10 + a.digits[i]; // 模拟将上一余数向下一位扩展
        quotient.digits[i] = current / b;           // 当前位的商
        remainder = current % b;                    // 更新余数
    }

    // 移除商中的前导0（高位多余的0）
    while (quotient.digits.size() > 1 && quotient.digits.back() == 0)
        quotient.digits.pop_back();

    return {quotient, remainder}; // 返回 商 和 余数
}

```

### 输出
```cpp
void printBigInt(const BigInt& a) {
    for (int i = a.digits.size() - 1; i >= 0; --i)
        std::cout << a.digits[i];
    std::cout << std::endl;
}
```



