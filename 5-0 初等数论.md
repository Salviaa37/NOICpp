---
source: https://ivanclf.github.io/2024/04/26/C++%20STL/
created: 2025-06-20
tags:
  - Cpp
  - Coding
---


## 数
整数：$-2,-1,0,1,2,3,4,5$，即正整数+0+负整数
**自然数（Natural Number）**：没有负数的整数，即0加上正整数。例如：$0,1,2,3,4,5$。
**正整数（Positive Integer）**：自然数除去$0$
**质数（质数，Prime Number）**：大于1的自然数，它的因数只有1和本身，不可分解成更小的数；2是唯一的偶质数。例如，$2,3,5,7,11,13,17,19$。
**合数（Composite Number）**：大于1不是质数的自然数，有除了1和本身之外的其他因数。例如：$4,6,8,9,10,12,14$。
**因数（Factor/Divisor）**：能整除某个正整数的数。例如：12的因数有$1,2,3,4,6,12$ 。
## 整数的性质 ★
### 质数唯一分解定理 3★
又称算术基本定理。
任何一个大于1的正整数a，要么是一个质数，要么能唯一地表示成素(质)因数的乘积(不考虑因数的排列顺序），即
$$
n = p_{1}^{a_{1}} \times p_{2}^{a_{2}} \times \cdots \times p_{k}^{a_{k}} 
$$
其中：
$p_1​,p_2​,…,p_k​$是互不相同的质数，这些==质数构成的集合是唯一的==（唯一性）。
$a_1​,a_2​,…,a_k$​ 是正整数的指数，



#### 解释
对于质数，其本身就是质数，如$31=31^0$
对于合数，$12= 2^2 × 3$ 是唯一分解，其他形式（如 $12=3 × 2^2$）视为等价。
$84=2^2×3×7$是唯一分解。



#### 意义
- 它说明了**质数是所有整数的“基本构件”**，就像化学元素构成所有分子一样。
- 它是很多数学理论（如最大公因数、最小公倍数、RSA 加密、欧几里得算法等）的基础。
- 它只在**整数领域成立**，在其他数域（如复数、有理数）中则不一定。

## 整除，取整

### 整除判定
常见的整除判定
1. 一个数的末位能被2或5整除，这个数就能被2或5整除；
2. ​​整除 3 或 9​​：各位数字之和能被 3 或 9 整除
3. ​​整除 5​​：末位是 0 或 5
4. ​​整除 4​​：最后两位数能被 4 整除
5. ​​整除 8​​：最后三位数能被 8 整除
6. ​​整除 6​​：同时能被 2 和 3 整除
7. ​​整除 11（奇偶位差法）​​：从右往左，奇数位数字之和 减 偶数位数字之和，其差能被 11 整除


### 整除的性质
1 如果 $a∣b$且 $a∣c$，那么对于任意整数 $x$ 和 $y$，都有：$a∣(b⋅x+c⋅y)$
也就是说，​​a 整除 b 和 c 的任意整数线性组合​​

👉 这是非常有用的性质，尤其是在证明最大公约数相关问题时。

2. ​​若 $a | b$，则 $a | (b × c)$ 对任意整数 c 成立​​
因为若 $b=a×q$，则 $b×c=a×(q×c)$
3. ​​传递性​​
如果 $a∣b$且 $b∣c$，那么 $a∣c$


### 取整


## 余数，同余
### 同余的定义★

​**​同余​**​是数论中的一个基本概念。给定一个正整数 $m$，如果两个整数 a和 b满足 $a−b$能被 $m$整除（即 m除 $a−b$的余数为 $0$），那么就称 ​**​a与 b对模 m同余​**​，记作：$$a≡b(\mod m)$$
​**​通俗理解：​**​
如果两个数$a$，$b$除以某个数 $m$得到的余数相同，那么这两个数对于模 $m$来说是同余的。

​
- $17÷5=3$余 2
- $12÷5=2$余 2
因为两者除以 5 都余 2，所以：$$17≡12(mod5)$$

也可以从定义验证：$17−12=5$，而 $5$ 能被 $5$ 整除，所以成立。



### 同余定理（同余的基本性质）★

同余具有以下一些重要的基本性质，这些性质也常被称为​**​同余定理​**​：
设 $a,b,c$是整数，$m$是一个正整数。

1. ​**​自反性：​**​
    $a≡a(\mod m)$
    _任何一个数与自己同余。_
2. ​**​对称性：​**​
    如果 a≡b(modm)，那么 b≡a(modm)。
3. ​**​传递性：​**​
    如果 a≡b(modm)且 b≡c(modm)，那么 a≡c(modm)。
4. ​**​加法性质：​**​
    如果 $a≡b(\mod m)$且 $c≡d(\mod m)$，那么：
    $a+c≡b+d(\mod m)$
5. ​**​减法性质：​**​
    如果 $a≡b(\mod m)$且 $c≡d(\mod m)$，那么：
    $a−c≡b−d(\mod m)$
6. ​**​乘法性质：​**​
    如果 $a≡b(\mod m)$且 $c≡d(\mod m)$，那么：
    $a×c≡b×d(\mod m)$
    $c,d$可以相同。
7. ​**​同幂性质（推广）：​**​
    如果 $a≡b(\mod m)$，那么对于任意正整数 n，有：
    $a^n≡b^n(\mod m)$
    

---

### 同余的应用

同余理论在数论、密码学、计算机科学等领域有广泛应用，比如：
- ​**​判断整除性​**​
- ​**​求解模方程​**​
- ​**​快速幂取模运算​**​
- ​**​中国剩余定理（CRT）​**​
- ​**​密码算法中的模运算​**​





## 质数与约束

## 质数筛法 4★

### 质数判断

朴素的质数判断方法，根据定理：
如果一个整数$n>1$是合数，那么它必定有一个**小于或等于** $\sqrt n$ 的质数因子。

```cpp
bool is_prime(int p){
	if(p < 2) return false; // 小于1不是质数
	for(int i = 2; i*i <= p; i++){ 
		if(p % i == 0) return false;
	}
	return true;
}
```


### 埃氏筛法（埃拉脱斯色尼筛法）

我们想要知道$1$到$n$之间有多少个质数呢？

一个自然的想法是对于小于等于 n 的每个数进行一次质数检验。这是一种暴力解法，这种算法不会有最优的复杂度。

要想简化计算，根据质数与合数的定义，对于任意一个大于 $1$ 的正整数 $n$，那么它的 $x$ （$x > 1$）倍就是合数。我们只要把这些倍数都标记为合数，就可以减少大量枚举式的质数检验了。

**埃氏筛法的思想：**
如果我们从小到大考虑每个质数，然后把当前这个质数的所有（比自己大的）倍数记为合数，那么程序运行结束的时候，没有被标记的数就是质数了。这就是埃氏筛法。

伪代码如下：
```cpp
for i in (2,n):
	if is_prime = true:
		result.add(i)
		for j in (2*i,n):
			is_prime[j] = false
			j += i
	
```
代码如下：
```cpp
vector<int> Eratosthenes(int n) {
    vector<int> prime;
    // 标记质数
    vector<bool> is_prime(n+1,true);
    // 标记0和1
    is_prime[0] = is_prime[1] = false;
    // 筛选
    // 从2开始遍历,2是质数
    for (int i = 2; i <= n; ++i) {
        // 如果是质数，开始筛选
        if (is_prime[i]) {
            // 添加到质数表
            prime.push_back(i);
            // 从i的倍数开始标记合数
            // 是 i 的倍数的均不是质数，循环将i的倍数标记为合数
            for (int j = 2 * i; j <= n; j += i)
                is_prime[j] = false;  
        }
    }
    return prime;
}
```
#### 优化
在对$i$的倍数标记合数的时候，我们可以从$i*i$开始。
**原理**：
小于$i$平方的倍数已经被更小的质数标记过了

**例子**：
$7$ 的倍数有：$7, 14, 21, 28, 35, 42, 49, ...$
$7^2= 49$
让我们看看 $49$ 之前的倍数：
$14 = 7 × 2$：已经被质数 2 标记为合数
$21 = 7 × 3$：已经被质数 3 标记为合数
$28 = 7 × 4 = 7 × 2^2$：已经被质数 2 标记为合数
$35 = 7 × 5$：已经被质数 5 标记为合数
$42 = 7 × 6 = 7 × 2 × 3$：已经被质数 2 标记为合数

**证明**：
对于质数 $p$，考虑$p × k$（其中$k < p$）：

如果 $k$ 是合数，那么 $p × k$ 已经被 $k$ 的素因子标记过了；
如果 $k$ 是质数且 $k < p$，那么 $p × k$ 已经在处理质数 k 时被标记过了；
因此，只有当 $k ≥ p$时，$p × k$ 才可能是第一次被标记，而最小的这样的 k 就是 $p$ 本身，即 $p × p = p^2$。
```cpp
vector<int> Eratosthenes(int n) {
    vector<int> prime;
    // 标记质数
    vector<bool> is_prime(n+1,true);
    // 标记0和1
    is_prime[0] = is_prime[1] = false;
    // 从2开始遍历
    for (int p = 2; p <= n; ++p) {
        // 如果是质数，开始筛选
        if (is_prime[p]) {
            // 添加到质数表
            prime.push_back(p);
            //if ((long long)p * p > n) continue;
            // 优化：从p的平方开始筛选
            for (int j = p*p; j <= n; j += p)
                // 是 p 的倍数的均不是质数
                is_prime[j] = false;  
        }
    }
    return prime;
}
```

以上为 **Eratosthenes 筛法**（埃拉托斯特尼筛法，简称埃氏筛法），时间复杂度是 $O(n\log\log{n})$。

> 这个时间复杂度证明极其复杂，记住即可。

#### 进一步优化
要找到直到 $n$ 为止的所有质数，仅对不超过 $\sqrt n$ 的质数进行筛选就足够了。也就是说，在筛选质数时，我们只需要筛选到 $n$ 的平方根即可。
**原理**：
如果一个整数$n>1$是合数，那么它必定有一个**小于或等于** $\sqrt n$ 的质数因子。

**例子：**
- 设 $n=35$， $\sqrt{35} \approx 5.9$， $35$ 的因数包括：$1, 5, 7, 35$，它的两个非平凡因数是 5 和 7，其中 $5 < 5.9$，所以有一个 ≤ $\sqrt{35}$；
- 再看 $n = 91$， $\sqrt{91} \approx 9.5$，$91 = 7 × 13$，因子 $7 < 9.5$，符合条件。

**证明：**
设 $n = a \times b$，其中 $a,b>1$，也就是说 $n$ 是合数。我们可以假设 $a \leq b$，则：
$$a \leq \sqrt{n} \quad \text{（因为 } a \times b = n \Rightarrow a \leq \sqrt{n} \leq b \text{）}$$

所以，合数 $n$ 至少可以写成两个因数的乘积，并且较小的那个因数 $a \leq \sqrt{n}$

若较小的数 $a$ 不是质数，则可以再继续分解，最终一定能得到一个小于或等于 $\sqrt{n}$的**素因子**。
反过来也可以推得，若一个整数 $n > 1$ 没有小于或等于 $\sqrt{n}$ 的素因子，则它是**质数**。

回到我们的优化过程，因为筛选是从小到大开始的，如果一个数n是合数，那么那个小于$\sqrt{n}$的质数因子就会筛选掉它，用不到大于$\sqrt{n}$的质数因子去筛选了。

筛选到平方根的代码：
```cpp
vector<int> Eratosthenes(int n) {
    vector<int> prime;
    // 标记质数
    vector<bool> is_prime(n+1,true);
    // 标记0和1
    is_prime[0] = is_prime[1] = false;
    // 筛选：标记质数
    // 优化：从2开始遍历，到n的平方根结束
    for (int p = 2; p * p <= n; ++p) {
        // 如果是质数，开始筛选
        if (is_prime[p]) {
            // 添加到质数表
            prime.push_back(p);
            // if ((long long)p * p > n) continue;
            // 从这个质数开始做标记，每个质数的p倍数均是合数
            for (int j = p * p; j <= n; j += p)
                // 是 p 的倍数的均不是质数 
                is_prime[j] = false;  
        }
    }
    return prime;
}
```
这样的优化虽然有效减少了操作次数，但是这种优化不会影响渐进时间复杂度，其复杂度为 $n \ln \ln \sqrt n + o(n)$，根据对数的性质，它们的渐进相同。

> [!note] 其他应用
> - **质数判断算法优化**：你只需试除到 $\sqrt{n}$​ 而不是到 $n$ 本身
> - **质因数分解加速**：尝试从小质数（2, 3, 5, 7...）开始试除到 $\sqrt{n}$ 即可。
> - **RSA 加密中大数素性测试**的理论基础也利用这一性质。


### 线性筛法（欧拉筛法）
埃氏筛法仍有优化空间，它会将一个合数重复多次标记。
例如：30在2（2×15）、3（3×10）、5（5×6）都会被标记一次，这就产生了大量的重复标记。
如果能除去重复的标记次数，让每个**合数都只被标记一次**，那么时间复杂度就可以降到 ![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "O(n)") $O(n)$了。这样我们就得到了线性筛法（Linear Sieve）。

**核心思想：**
线性筛法保证每个合数只会被筛掉一次，并且是被这个合数的最小素因子筛掉的。
例如：在线性筛法中，30只会被最小的质数因子2筛掉一次。

**实现原理**：
1 维护一个质数表，对每个循环数 $i$，筛选质数并加入质数表。
2 对每个循环数 $i$，我们只用当前已知的质数 $p$（位于质数表中） 去乘以 i，形成合数 $i × p$，并标记它为合数（筛掉它）。
3 但一旦发现 $p$ 是 $i$ 的最小素因子，就停止对 $i$ 的后续处理，保证合数 $i × p$是被自己的最小素因子$p$筛掉的。

设质数表中的质数$p_j$，循环数$i$，要被筛掉的合数 $x=i\times p_j$
若 $i\bmod p_j\ne 0$
- 说明数 $i$ 没有$p_j$这个素因子
- 又因为我们的 $j$ 是从小到大遍历的，所以 $p_j$ 比 $i$ 的所有素因子都小
- $i$ 乘以 $p_j$ 得到 $x$ ， $p_j$ 自然也就是$x$最小的素因子，继续筛选，下一个质数$p_{j+1}$就是$x_k = i*p_{j+1}$的最小素因子。

若 $i\bmod p_j= 0$
- 说明 $i$ 有$p_j$这个素因子
- 因为我们的 $j$ 是从小到大遍历的，说明$p_j$是 $i$ 的最小的素因子
- $i$ 乘以 $p_j$ 得到 $x$ ， $p_j$ 仍然是$x$最小的素因子。但是如果继续筛选，下一个质数$p_{j+1}$就不再是$x_k = i*p_{j+1}$的最小素因子了（因为$i$中包含了更小的素因子$p_j$，会出现重复筛选的情况，因此，应当终止当前标记合数的循环。

综上，每个数$x$都是被其最小的质因子 $p_j$ 给筛掉的。
```
i=4 (composite), primes=[2,3]
  Mark 8=4*2 [BREAK: 2 divides 4]
```

线性筛法的代码：
```cpp
vector<int> EulerSieve(int n) {
    vector<int> prime;
    vector<bool> is_prime(n+1, true);
    is_prime[0] = is_prime[1] = false;
    
	// 筛选
    // 线性筛法（欧拉筛法），从2筛到n
    for (int i = 2; i <= n; ++i) {
        // 如果 i 是质数
        if (is_prime[i]) {
	        // 添加到质数表
            prime.push_back(i);
        }
        
        // 标记合数
        // 用当前已找到的质数去筛选后面的合数
        // 范围：j遍历质数表，i与质数表的倍数应该小于等于n
        for (int j = 0; j < prime.size() && i * prime[j] <= n; j++) {
	        // 用当前质数表中的每个质数去标记合数
            is_prime[i * prime[j]] = false;
            
            // 关键优化：如果 i 能被 prime[j] 整除，说明如果继续筛选，就不是最小素因子，则退出
            // 这保证每个合数只被其最小素因子筛选一次
            if (i % prime[j] == 0) {
                break;
            }
        }
    }
    return prime;
}
```

代码解释：
对于每个数 i，用所有已找到的质数 `prime[j] `去标记合数 `i * prime[j]`
当` i % prime[j] == 0` 时停止标记，因为：`prime[j]` 是 i 的最小素因子

对于更大的质数 `prime[k]`，合数` i * prime[k]` 会在后续的某个数 i' 中被标记。

**示例：**
```
Linear Sieve Demo (n=15)
=======================

i=2 (PRIME), primes=[2]
  Mark 4=2*2 [BREAK: 2 divides 2]
i=3 (PRIME), primes=[2,3]
  Mark 6=3*2  Mark 9=3*3 [BREAK: 3 divides 3]
i=4 (composite), primes=[2,3]
  Mark 8=4*2 [BREAK: 2 divides 4]
i=5 (PRIME), primes=[2,3,5]
  Mark 10=5*2  Mark 15=5*3
i=6 (composite), primes=[2,3,5]
  Mark 12=6*2 [BREAK: 2 divides 6]
i=7 (PRIME), primes=[2,3,5,7]
  Mark 14=7*2
i=8 (composite), primes=[2,3,5,7]

i=9 (composite), primes=[2,3,5,7]

i=10 (composite), primes=[2,3,5,7]

i=11 (PRIME), primes=[2,3,5,7,11]

i=12 (composite), primes=[2,3,5,7,11]

i=13 (PRIME), primes=[2,3,5,7,11,13]

i=14 (composite), primes=[2,3,5,7,11,13]

i=15 (composite), primes=[2,3,5,7,11,13]

Result: 2 3 5 7 11 13 (6 primes)
```






## 最大公约数和最小公倍数

### 辗转相除法（欧几里得算法）★
辗转相除法（欧几里得算法，Euclidean Algorithm）是一种用于求两个整数的最大公约数（GCD, Greatest Common Divisor）的经典算法。

#### 基本思想
两个整数的最大公约数等于==其中较小的数==和==两数之差==的最大公约数。
即：
`gcd(a, b) = gcd(b, a % b)`，直到`a%b`的余数为 `0`。

#### 算法步骤
1 取两个数`a`和`b`进行模运算，即`a%b = c`
2 当a能被b整除时即` c == 0`，直接返回 `b` ，`b`就是最大公约数。
> 例如，$a=12$，$b=6$，$a\mod b=0$，$b=6$就是这两个数的最大公约数。

3 当a不能被b整除时即 `a%b != 0`进行辗转相除：用 a 来接收 b（`a=b`）的值，用 b 来接收 c （`b=c`）的值。重复步骤1

通俗一点，辗转相除：不能整除时，把a赋值为b，b赋值为a%b，直到可以整除为止。 
代码：
```cpp
int gcd(int a, int b){
    while(b != 0){
	    int c = a%b;
	    a = b;
	    b = c;
    }
    return a;
}
```


## C++ cmath库（数学函数）

`<cmath>` 是 C++ 标准库中的一个头文件，它提供了许多基本的数学运算和常数。这些数学函数可以执行基本的数学运算，如幂运算、三角函数、对数、绝对值等。

要使用 `<cmath>` 中的函数，你需要在你的 C++ 程序中包含这个头文件：
```cpp
#include <cmath>
```


### 常用数学函数
所有函数参数均支持 `int` / `long long` / `float` / `double` / `long double`

| 公式含义     | 示例                                                            | 英文全称        | 数学符号           |
| -------- | ------------------------------------------------------------- | ----------- | -------------- |
| 绝对值      | `abs(-1.0) == 1.0`<br>`abs(3.0) == 3.0`<br>`abs(-2.5) == 2.5` | absolute    | $\|-1.0\|=1.0$ |
| 幂次       | `pow(2, 3)== 2^3 == 8`                                        | power       |                |
| 平方根      | `sqrt(16) == √16 == 4`                                        | square root |                |
| 向上取整     | `ceil(2.1) == 3`                                              | ceiling     |                |
| 向下取整     | `floor(2.1) == 2`                                             | floor       |                |
| 舍入（四舍五入） | `round(2.1)==2`<br>`round(2.5)==3`                            | round       |                |


**注意事项**  
由于浮点数误差（小数点后舍入的问题），有些的数学函数的行为可能与预期不符，在跑程序的时候出现不符合要求的情况（ WA，Wrong Answer）。






