
## 🎓 动态规划讲义（C++版）

---

### 📌 一、什么是动态规划（Dynamic Programming）？

动态规划是一种**解决具有重叠子问题和最优子结构性质问题**的算法设计方法。

- **重叠子问题**：一个大问题可以分解为若干小问题，小问题会被重复计算。
    
- **最优子结构**：大问题的最优解可以由小问题的最优解推出。
    

动态规划的核心思想是：

> **把问题拆成子问题，保存子问题的解，避免重复计算。**

---

### 📌 二、常见应用场景

- 斐波那契数列
    
- 背包问题（0-1背包、完全背包）
    
- 最长上升子序列（LIS）
    
- 编辑距离
    
- 股票买卖
    
- 矩阵路径问题
    

---

### 📌 三、解题步骤套路（五步法）

1. **定义状态（dp数组的含义）**
    
2. **确定初始状态**
    
3. **状态转移方程**
    
4. **确定计算顺序（递推 or 递归 + 记忆化）**
    
5. **输出结果**
    

---

### 📌 四、案例一：斐波那契数列

#### 🧩 问题描述：

第 n 个斐波那契数，定义为：

- F(0) = 0
    
- F(1) = 1
    
- F(n) = F(n-1) + F(n-2)
    

---

#### ✅ 动态规划解法（自底向上）：

```cpp
#include <iostream>
#include <vector>
using namespace std;

int fibonacci(int n) {
    if (n <= 1) return n;

    vector<int> dp(n + 1);
    dp[0] = 0;  // 初始状态
    dp[1] = 1;

    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];  // 状态转移方程
    }

    return dp[n];
}

int main() {
    int n = 10;
    cout << "F(" << n << ") = " << fibonacci(n) << endl;
    return 0;
}
```

---

### 📌 五、案例二：0-1 背包问题

#### 🧩 问题描述：

有 n 件物品和一个容量为 W 的背包，每件物品有重量 `w[i]` 和价值 `v[i]`。求在不超过背包容量的前提下可以获得的最大价值。

---

#### ✅ 动态规划解法（二维 dp）

```cpp
#include <iostream>
#include <vector>
using namespace std;

int knapsack(int W, vector<int>& weights, vector<int>& values, int n) {
    vector<vector<int>> dp(n + 1, vector<int>(W + 1, 0));

    for (int i = 1; i <= n; i++) {
        for (int w = 0; w <= W; w++) {
            if (w >= weights[i - 1])
                dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1]);
            else
                dp[i][w] = dp[i - 1][w];
        }
    }

    return dp[n][W];
}

int main() {
    vector<int> weights = {2, 1, 3};
    vector<int> values = {4, 2, 3};
    int W = 4;
    int n = weights.size();

    cout << "最大价值为: " << knapsack(W, weights, values, n) << endl;
    return 0;
}
```

---

### 📌 六、优化技巧

#### 🎯 滚动数组优化（空间优化）

将二维 `dp[i][w]` 优化为一维 `dp[w]`，从大到小遍历容量：

```cpp
for (int i = 0; i < n; i++) {
    for (int w = W; w >= weights[i]; w--) {
        dp[w] = max(dp[w], dp[w - weights[i]] + values[i]);
    }
}
```

---

### 📌 七、递归 + 记忆化搜索（Top-down）

也称为“记忆化搜索”或“备忘录法”。

以斐波那契数列为例：

```cpp
#include <iostream>
#include <vector>
using namespace std;

int fib(int n, vector<int>& memo) {
    if (n <= 1) return n;
    if (memo[n] != -1) return memo[n];

    return memo[n] = fib(n - 1, memo) + fib(n - 2, memo);
}

int main() {
    int n = 10;
    vector<int> memo(n + 1, -1);
    cout << "F(" << n << ") = " << fib(n, memo) << endl;
    return 0;
}
```

---

### 📌 八、常见陷阱和建议

|问题|建议|
|---|---|
|无法确定状态含义|从样例手动模拟，找规律|
|状态转移方程不清晰|写出第 i 步和第 i-1 步对比|
|忘记初始化 dp|明确 dp 的初始意义并初始化|
|数组越界或访问错误|注意下标从 0 还是 1 开始|

---

### 📌 九、经典题目推荐（Leetcode）

1. [70. 爬楼梯](https://leetcode.com/problems/climbing-stairs/)
    
2. [198. 打家劫舍](https://leetcode.com/problems/house-robber/)
    
3. [300. 最长上升子序列](https://leetcode.com/problems/longest-increasing-subsequence/)
    
4. [322. 零钱兑换](https://leetcode.com/problems/coin-change/)
    
5. [416. 分割等和子集](https://leetcode.com/problems/partition-equal-subset-sum/)
    

---

如需我将这份讲义生成 PDF 或 Word 文档，也可以告诉我。是否还希望继续添加其他例题或专题（如 LIS、编辑距离、状态压缩等）？