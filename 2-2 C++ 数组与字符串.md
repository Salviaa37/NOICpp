
## 数组

[动画讲解C语言指针-15-二维数组和指针_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV17w4m1o787/?spm_id_from=333.337.search-card.all.click&vd_source=574e0a38261401341cd391f17b73fdad)

### 数组的定义


### 一维数组


### 多维数组


## 字符串
字符串（string）实际上是用null字符即`\0`终止的一维字符数组。内容固定的字符串叫==字符串常量==，它用==双引号==括起来，而==字符常量用单引号==括起来。

即使==一个字符的字符串==也不是字符类型，因为字符串末尾有`\0`作为结束符，而字符（char类型）不存在结束符的说法。

作为C语言的扩充，C++提供了两种类型的字符串表示形式：
- C语言风格的字符串，字符串相关操作在头文件`cstring`中；
- C++引入的string类，string类在头文件`string`中。

####  C风格字符串
可以使用**字符数组**或者**指针**定义一个C风格字符串。

特点是字符串长度确定，无法更改。
但可以通过索引（下标）修改字符。
```cpp
#include <cstdio>
using namespace std;
int main(){
	char str[] = "I love china";
	printf("%s\n",str);
	return 0;
}
```

字符指针
支持动态更新字符串，整体赋值。
不可以通过索引修改字符。
```cpp
#include<cstdio>
using namespace std;
int main(){
	char *str = "I love china";
	char *strb = str;
	printf("%s\n",str);
	return 0;
}
```



#### C++ string类

##### **初始化**
string类提供了很多种构造函数，用来创建和初始化字符串。
```cpp
#include<iostream>
#include<string>
using namespace std;

string str; // 创建一个空字符串
string s1("Hello"); // 从C字符串初始化
string s2(s1); // 复制构造函数,把字符串s1复制过来
string s4(5, 'a'); // 使用5个'a'字符初始化
```

##### 常用操作
```cpp
#include<iostream>
#include<string>
using namespace std;
int main(){
	string s1="Hello";
	string s2="wor1d";
	string s3;
	
	s3=s1; //赋值s1到s3
	cout<<"s3:"<<s3<<endl;
	
	s3=s1+s2; //连接s1和s2
	cout<<"s1+s2:"<<s3<<endl;
	
	int len=s3.size();//连接后s3的总长度
	cout<<"s3.size():"<<len<<endl;

	return 0;
}
```


##### **常用string操作方法**

| 函数      | 全拼        | 头文件    | 功能描述                | 实例                          |
| ------- | --------- | ------ | ------------------- | --------------------------- |
| empty   | empty     | string | 判断字符串是否为空，返回bool表达式 | `s.empty()`                 |
| getline | getline   | string | 带空格的字符串输入           | `getline(cin, s)`           |
| size    | size      | string | 求字符串的长度             | `s.size()`                  |
| insert  | insert    | string | 在母串某个位置插入子串         | `s.insert(pos, s2)`         |
| substr  | substring | string | 求子串                 | `s.substr(pos, len)`        |
| erase   | erase     | string | 删除特定长度字符            | `s.erase(pos, len)`         |
| find    | find      | string | 查找子串的位置             | `s.find(sub)`               |
| replace | replace   | string | 替换子串                | `s.replace(pos, len, news)` |
| c_str   |           | string | 获取C语言风格的字符数组首地址指针   | `s.c_str()`                 |

##### 使用实例
```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    // 声明并初始化字符串
    string str = "Hello, World!";
    cout << str << endl;

    // 使用 size() 获取字符串长度
    cout << "字符串长度: " << str.size() << endl;

    // 使用 empty() 检查字符串是否为空
    cout << "字符串是空的吗? " << (str.empty() ? "Yes" : "No") << endl;

    // 使用 operator[] 访问特定位置的字符
    cout << "第7个位置的字符: " << str[7] << endl;

    // 使用 substr() 获取子字符串
    string sub = str.substr(7, 5);
    cout << "第7个位置开始长度为5的字符串: " << sub << endl;

    // 使用 find() 查找子字符串
    cout << "字符串中'World'的位置: " << str.find("World") << endl;

    // 使用 replace() 替换字符串中的部分内容
    // 替换 'World' 为 'C++'
    string modified = str;
    string::size_type pos = modified.find("World");
    if (pos != string::npos) {
        modified.replace(pos, 5, "C++"); // 从位置 pos 开始，替换 5 个字符为 "C++"
    }
    cout << "经过替换的字符串: " << modified << endl;
    
	// 使用 getline() 从用户输入读取一整行
    string userInput;
    cout << "\n请输入一行文本: ";
    cin.ignore(); // 清除之前可能的输入缓冲
    getline(cin, userInput);
    cout << "您输入的是: " << userInput << endl;

    return 0;
}




```

## 字符串算法
### KMP算法

### Boyer-Moole算法
前置知识：[前缀函数与 KMP 算法](https://oi-wiki.org/string/kmp/)。

KMP 算法将前缀匹配的信息用到了极致，

而 BM 算法背后的基本思想是通过后缀匹配获得比前缀匹配更多的信息来实现更快的字符跳转。

### Sunday 算法

Sunday算法是一种高效的字符串匹配算法，由Daniel M.Sunday在1990年提出。它的思想与BM算法相似，但在匹配失败时，关注的是主串中参与匹配的最末位字符的下一位字符。

算法原理
Sunday算法从前往后匹配，当匹配失败时，查看主串中参与匹配的最末位字符的下一位字符。如果该字符不在模式串中出现，则直接跳过，移动位数为模式串长度加1；否则，移动位数为模式串长度减去该字符在模式串中最右出现的位置。

例如，在主串 `substring searching` 中查找模式串 `search` 时：
1. 初始对齐，发现第`2`个字符不匹配，关注字符'i'，因'i'不在模式串中，移动位数为`7`。
2. 继续匹配，发现字符'r'，在模式串中倒数第`3`位，移动位数为`3`。
3. 最终匹配成功。

代码：
```cpp
#include <iostream>
#include <string>
using namespace std;

const int maxNum = 1005;
int shift[maxNum];

int Sunday(const string& T, const string& P) {
	int n = T.length();
	int m = P.length();
	// 初始化移动位数
	for (int i = 0; i < maxNum; i++) {
		shift[i] = m + 1;
	}

	// 计算每个字符的移动位数
	for (int i = 0; i < m; i++) {
		shift[P[i]] = m - i;
	}
	
	int s = 0; // 模式串在主串中的位置
	int j; // 模式串匹配位置
	
	while (s <= n - m) {
		j = 0;
		while (T[s + j] == P[j]) {
			j++;
			if (j >= m) {
				return s; // 匹配成功
			}
		}
		s += shift[T[s + m]]; // 移动模式串
	}
	return -1; // 匹配失败
}

  

int main() {
	string T, P;
	while (true) {
		getline(cin, T);
		getline(cin, P);
		int res = Sunday(T, P);
		if (res == -1) {
			cout << "主串和模式串不匹配。" << endl;
		} else {
			cout << "模式串在主串的位置为：" << res << endl;
		}
	}
	return 0;
}
```

#### 算法分析
Sunday算法的预处理时间复杂度为$O(|∑| + m)$，最坏情况下的时间复杂度为$O(nm)$，平均时间复杂度为$O(n)$，空间复杂度为$O(|∑|)$   
[3](https://blog.csdn.net/qq_52269550/article/details/121361709)。
尽管存在最坏情况，但在大多数情况下，Sunday算法仍然是一个简单高效的字符串匹配算法。