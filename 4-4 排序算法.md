---
Date: 2025-06-06
source: https://mp.weixin.qq.com/s/4XzoXPG7z-KHY1an_VmMvQ
author: https://zhuanlan.zhihu.com/p/122284534
---

## 定义

排序（Sort） 是指将一组==无序数据==按特定顺序（升序/降序）重新排列的过程。常见的排序算法有：冒泡排序、选择排序、插入排序、快速排序、归并排序、桶排序等。

为了便于描述，凡是涉及排序的内容，==默认按照升序排序==。

数学定义：
将一组杂乱无章的数据按一定的规律顺次排列起来。例如：
输入：`a1，a2，a3，…，an`
输出：`a1’，a2’，a3’，…，an’（满足a1′ <= a2′ <= a3′ <= … <= an’排列）`

## 常用概念

### 排序算法的稳定性
**稳定**：如果a原本在b前面，而a=b时，排序之后a仍然在b的前面。  
**不稳定**：如果a原本在b的前面，而a=b时，排序之后a可能出现在b的后面。  


**排序算法的稳定性**是指：当两个元素的键值相等时，排序前后它们的相对位置是否保持不变。

- **稳定排序**：相等元素的相对顺序保持不变
- **不稳定排序**：相等元素的相对顺序可能改变

#### 稳定性的重要性

排序稳定性在以下情况特别重要：

1. **多级排序**：先按一个键排序，再按另一个键排序
2. **对象排序**：当对象有多个属性，只按其中一个属性排序时
3. **应用场景**：如学生成绩单先按班级排序，再按分数排序

#### 常见排序算法的稳定性

稳定的排序算法：
- 冒泡排序
- 插入排序
- 归并排序
- **计数排序**
- 桶排序
- 基数排序

不稳定的排序算法：
- 选择排序
- 希尔排序
- 快速排序
- 堆排序

在选择排序算法时，应根据需求考虑其稳定性特征。

### 内排序与外排序
由于待排序的记录数量不同，使得排序过程中涉及的存储器不同，可将排序方法分为两大类：内排序与外排序。

**内排序**
所有排序操作都在内存中完成。  插入排序、快速排序、选择排序、归并排序、基数排序等目前竞赛研究的算法基本上都是内排序方法。

**外排序**
待排序记录的数量很大，以致于内存不能一次容纳全部数据记录，根据排序过程的需要而在外存与内存之间 数据传输才能进行。  


#### 衡量效率的方法
1.内排序：比较次数，也就是时间复杂度。
2.外排序：IO次数，也就是读写外存的次数。

### 排序算法复杂度

**时间复杂度**：时间频度，一个算法执行所耗费的时间。算法中通常用==数据比较次数==与==数据移动次数 ==进行衡量。  
**空间复杂度**：算法执行所需要的内存大小。

| 排序法          | 最坏时间                 | 平均时间复杂度        | 稳定性 | 空间复杂度         |
| ------------ | -------------------- | -------------- | --- | ------------- |
| ==**插入排序**== | $O(n^2)$             | $O(n^2)$       | 稳定  | $O(1)$        |
| ==**选择排序**== | $O(n^2)$             | $O(n^2)$       | 不稳定 | $O(1)$        |
| ==**冒泡排序**== | $O(n^2)$             | $O(n^2)$       | 稳定  | $O(1)$        |
| 希尔排序         | $O(n^s)$ (1 < s < 2) | $O(n\log_2 n)$ | 不稳定 | $O(1)$        |
| 快速排序         | $O(n^2)$             | $O(n\log_2 n)$ | 不稳定 | $O(\log_2 n)$ |
| 堆排序          | $O(n\log n)$         | $O(n\log_2 n)$ | 不稳定 | $O(1)$        |
| 归并排序         | $O(n\log n)$         | $O(n\log_2 n)$ | 稳定  | $O(n)$        |
| **==计数排序==** | $O(n + k)$           | $O(n + k)$     | 稳定  | $O(n + k)$    |

## 常见需要掌握的排序算法

[[#冒泡排序]]
[[#选择排序]]
[[#插入排序]]
[[#计数排序]]



# 冒泡排序


## 冒泡排序简介
  


冒泡排序（Bubble Sort） 是最简单的排序算法，在排序的过程中，每个数据就像水中的气泡一样，按照一定顺序，依次浮出水面。




## 排序步骤与编程实现

视频讲解：
[数据结构合集 - 简单选择排序(选择排序)(算法过程, 效率分析, 稳定性分析)](https://www.bilibili.com/video/BV1kjsuenE8v?vd_source=574e0a38261401341cd391f17b73fdad&spm_id_from=333.788.videopod.sections)

- 将相邻元素两两比较，==将较大的元素后移==，经过这一轮的比较，最大元素被排在最后面 。
- 将剩余元素按照上述操作，再比较一轮，第二大元素会排在倒数第二位。
- 依次类推，直到剩余元素只有1个，排序结束。

动态图示：[bfee96cbfb60a025af6744aa7ee2c21c.gif (826×257)](https://developer.qcloudimg.com/http-save/yehe-11163510/bfee96cbfb60a025af6744aa7ee2c21c.gif)
### 一、排序步骤：

示例数组：{ 1, 5, 2, 8, 3 }

第一轮 比较如下：

每次比较的两个元素加、粗倾斜显示，排序好的元素加粗、加下划线。

| 次数  | 比较前                   | 操作  | 比较后                   |
| --- | --------------------- | --- | --------------------- |
| 1   | { ==1, 5,== 2, 8, 3 } | 不交换 | { ==1, 5==, 2, 8, 3 } |
| 2   | { 1, ==5, 2==, 8, 3 } | 交换  | { 1, ==2, 5==, 8, 3 } |
| 3   | { 1, 2, ==5, 8==, 3 } | 不交换 | { 1, 2, ==5, 8,== 3 } |
| 4   | { 1, 2, 5, ==8, 3== } | 交换  | { 1, 2, 5, ==3, 8== } |

  

第二轮 比较如下：

| 次数  | 比较前               | 操作  | 比较后               |
| --- | ----------------- | --- | ----------------- |
| 1   | { 1, 2, 5, 3, 8 } | 不交换 | { 1, 2, 5, 3, 8 } |
| 2   | { 1, 2, 5, 3, 8 } | 不交换 | { 1, 2, 5, 3, 8 } |
| 3   | { 1, 2, 5, 3, 8 } | 交换  | { 1, 2, 3, 5, 8 } |

  

第三轮 比较如下：

| 次数 | 比较前 | 操作 | 比较后 |
| --- | --- | --- | --- |
| 1 | { 1, 2, 3, 5, 8 } | 不交换 | { 1, 2, 3, 5, 8 } |
| 2 | { 1, 2, 3, 5, 8 } | 不交换 | { 1,2, 3, 5, 8 } |


第四轮 比较如下：

| 次数 | 比较前 | 操作 | 比较后 |
| --- | --- | --- | --- |
| 1 | { 1, 2, 3, 5, 8 } | 不交换 | { 1,2, 3, 5, 8 } |

最终的排序结果是：{ 1, 2, 3, 5, 8 }


【 归纳总结】

1、排序的轮数比排序元素的个数少1，也就是外层循环n-1次，
外层循环范围 
2、每轮成功排序一个元素，因此每轮排序的次数依次递减，最后一轮排序的次数为1。
内层循环范围


### 二、编程实现：

```cpp
#include <bits/stdc++.h>
using namespace std;

// 变量n表示输入元素的个数
// 数组a用于存储输入的元素
void bubble(int a[], int n){
    int temp = 0;
    for(int i = 0; i < n - 1; i++){
        for(int j = 0; j < n - 1 - i; j++){

            if(a[j] > a[j+1]){
                temp = a[j+1];
                a[j+1] = a[j];
                a[j] = temp;
            }
        }
    }
}
```
## 冒泡排序的优化


对于上面的排序过程，细心的你会发现：第三轮比较没有做任何交换。

那么，第四轮比较是不是可以省略呢？

先独立思考一下……

如果可以省略第四轮比较，说明排序可以提前结束，这意味着冒泡排序有优化的余地。

如果==在某一轮排序没有做任何交换，说明剩余元素已经有序==，无需继续排序，终止for循环。

所以，只需增加一个标识变量用来记录当前一轮有没有发生交换操作，如果有，就继续下一轮比较；如果没有，就终止循环。

冒泡排序优化示例如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
// 变量n表示输入元素的个数
// 数组a用于存储输入的元素
void bubble_optim(int a[], int n){
    int temp = 0;
    int passes = 0; // 记录比较轮数
    for(int i = 0; i < n - 1; i++){
        bool flag = false;  // 当前轮次是否发生比较？
        passes +=1;
        for(int j = 0; j < n - 1 - i; j++){
            
            if(a[j] > a[j+1]){
                temp = a[j+1];
                a[j+1] = a[j];
                a[j] = temp;

                flag = true;
            }
        }
        if(!flag) break;
    }
    cout << passes << endl;
}

```

  冒泡排序的改进在某些情况下确实有效，尤其是：

1. **已经排序或近乎排序的数组**：提前退出循环可以大幅减少比较次数
2. **大型数组**：当数组大小增加时，优化的好处会更加明显

对于随机数组或逆序数组，优化效果会不太明显甚至没有效果，因为：

- 对于逆序数组，每轮都会发生交换，flag始终为true，无法提前退出
- 对于随机数组，可能需要比较多轮才能完成排序，提前退出的机会有限

所以，冒泡排序的这种优化是有效的，但效果取决于数据的初始排列情况。




## 性能分析

平均时间复杂度：O(N^2)  
最佳时间复杂度：O(N^2)  
最差时间复杂度：O(N^2)  
空间复杂度：O(1)  
排序方式：In-place  
稳定性：不稳定

选择排序的交换操作介于和(n-1)次之间。选择排序的比较操作为n(n-1)/2次之间。选择排序的赋值操作介于0和3(n-1)次之间。

比较次数O(n^2)，比较次数与关键字的初始状态无关，总的比较次数N = (n-1) + (n-2) +…+ 1 = n x (n-1)/2。交换次数O(n)，最好情况是，已经有序，交换0次；最坏情况是，逆序，交换n-1次。



# 插入排序
## 插入排序简介

为了便于描述，凡是涉及排序的内容，默认按照升序排序。

插入排序（Insertion Sort） 是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对未排序元素，在已==排序序列中从后往前扫描==，找到相应位置并插入。

  
## 排序步骤与编程实现

模拟场景：打扑克牌时摸牌与整理手牌；站成一队时候老师按身高调整队列。


视频讲解：[数据结构合集 - 直接插入排序(算法过程, 效率分析, 稳定性分析)哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1tf421Q7eh/?vd_source=574e0a38261401341cd391f17b73fdad)

#### 一、排序步骤：

1、将排序元素分成==已排序 和 未排序 ==两部分； 

2、初始时，已排序部分只包含第一个元素；

3、每次==从未排序元素中取出第一个元素==，与==已排序元素从后往前==（从前往后也可以）比较；

4、重复步骤3，直到找到已排序的元素不大于新元素的位置

5、将新元素==插入到该位置后==

6、重复3~5步，直到排序结束。

动图演示：[v2-91b76e8e4dab9b0cad9a017d7dd431e2_b.webp (811×505)](https://pic1.zhimg.com/v2-91b76e8e4dab9b0cad9a017d7dd431e2_b.webp)

具体操作过程如下：

备注：已排序元素加粗显示。

  

| 轮次  | 操作             | 当前数组                  |
| --- | -------------- | --------------------- |
| 0   | 初始数组，默认第一个数已排序 | { ==1==, 5, 2, 8, 3 } |
| 1   | 取出元素5，执行3~5操作  | { ==1, 5,== 2, 8, 3 } |
| 2   | 取出元素2，执行3~5操作  | { ==1, 2, 5,== 8, 3 } |
| 3   | 取出元素8，执行3~5操作  | { ==1, 2, 5, 8,== 3 } |
| 4   | 取出元素3，执行3~5操作  | { ==1, 2, 3, 5, 8== } |

最终的排序结果是：{ 1, 2, 3, 5, 8 }。

  

【 归纳总结】

1、排序的轮数比排序元素的个数少1，外层循环n-1。但要注意，因为指定第一个元素为已排序元素，外层循环从第二个元素开始，

2、每轮排序都会排好一个元素，有序部分加1，无需部分减1。内层循环使用while循环


#### 二、编程实现：

```cpp
#include <iostream>
using namespace std;

// 声明插入排序函数，接收一维数组和数组长度两个参数，无返回值
void insertion_sort(int a[], int n){
	// 外层循环从1开始，到末尾
    for(int i = 1; i < n; i++){
        // 选定待排序元素
        int tmp = a[i];
        // 已排序元素范围
        int j = i - 1;
        // 在已排序元素中寻找插入位置
        // 待排序元素更小且在已排序序列范围内，向前移动
        while(j >= 0 && tmp < a[j]){
	        // 序列向后移动一个位置，意味着待排序元素前移
            a[j+1] = a[j];
            j--;
        }
        // 将待排序元素插入到该位置后面
        a[j+1] = tmp;
    }
}

int main(){
    int a[10] = {1,2,43,4,5,6,8,19,7,10};
    insertion_sort(a,10);
    for(int i = 0;i < 10;i++) cout << a[i] << ' ';
    cout << endl;
    return 0;
}

```

## 性能分析

> 平均时间复杂度：O(N^2)  
> 最差时间复杂度：O(N^2)  
> 空间复杂度：O(1)  
> 排序方式：In-place  
> 稳定性：稳定

如果插入排序的目标是把n个元素的序列升序排列，那么采用插入排序存在最好情况和最坏情况：

> (1) 最好情况：序列已经是升序排列，在这种情况下，需要进行的比较操作需(n-1)次即可。  
> (2) 最坏情况：序列是降序排列，那么此时需要进行的比较共有n(n-1)/2次。

插入排序的赋值操作是比较操作的次数减去(n-1)次。平均来说插入排序算法复杂度为O(N^2)。

最优的空间复杂度为开始元素已排序，则空间复杂度为 0；

最差的空间复杂度为开始元素为逆排序，则空间复杂度最坏时为 O(N);

平均的空间复杂度为O(1)。



# 计数排序
## 计数排序简介

为了便于描述，凡是涉及排序的内容，默认按照升序排序。

计数排序（Counting Sort） 是一种 非比较型 的排序算法。它是通过统计元素出现的次数实现排序。
计数排序的核心原理是对每一个输入元素 **x**, 确定小于 **x** 的元素个数。利用这一信息，就可以直接把 **x** 放到它在输出数组中的位置上了。例如，如果有 17 个元素小于 **x** , 则 **x** 就应该在第18个输出位置上。
当有几个元素相同时，这一方案要略做修改。因为不能把它们放在同一个输出位置上。

## 排序步骤与编程实现

视频讲解：[排序算法：计数排序【图解+代码】_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1KU4y1M7VY)
  

动图演示：[d45a61779499f84f381fc30e0076975c.gif (1012×557)](https://developer.qcloudimg.com/http-save/yehe-11163510/d45a61779499f84f381fc30e0076975c.gif)；
[94e8485e8bf06f4ca77f1382e396e68a.gif (967×662)](https://developer.qcloudimg.com/http-save/yehe-11163510/94e8485e8bf06f4ca77f1382e396e68a.gif)
### 一、排序步骤：

1. 找出待排序元素中的最大元素；
2. 创建计数数组，长度为==最大元素+1==，==初始化为0==；
3. 统计每个元素出现的次数，存入计数数组中；
4. 根据计数数组的统计情况，求出每个数出现的位置；
5. 利用出现位置计算每个数的排序位置。

  

具体操作过程如下：

设有待排序数组：`arr = { 3, 5, 1, 6, 2, 3, 5, 1, 6, 5 }`。

 1、确定数据范围

首先找出数组中的最大值和最小值：最小值为1，最大值为6。

 2、创建计数数组

由于最大元素为6，我们需要创建一个**长度为(最大元素+1)**的计数数组，用于存储每个元素出现的次数。

创建长度为7的计数数组：`count = {0, 0, 0, 0, 0, 0, 0}`。

> 注：如果最大元素为11，那么计数数组大小就应该是12，索引范围为0-11。

 3、统计元素频率

遍历原始数组`arr`中的每个元素，统计其出现的次数并存入对应的`count`数组位置：

| 索引(元素值) | 0   | 1   | 2   | 3   | 4   | 5   | 6   |
| ------------ | --- | --- | --- | --- | --- | --- | --- |
| 出现次数     | 0   | 2   | 1   | 2   | 0   | 3   | 2   |

统计完成后，计数数组`count = { 0, 2, 1, 2, 0, 3, 2 }`，表示：
- 元素0出现了0次
- 元素1出现了2次
- 元素2出现了1次
- 元素3出现了2次
- 元素4出现了0次
- 元素5出现了3次
- 元素6出现了2次

4、累加计数确定位置

将计数数组中的值**从左到右**进行累加，使每个位置存储的值表示"小于等于该索引的元素个数"：

原始计数：`count = { 0, 2, 1, 2, 0, 3, 2 }`
累加后：`count = { 0, 2, 3, 5, 5, 8, 10 }`

这个累加后的数组告诉我们：
- 小于等于1的元素有2个，因此元素1的最后位置是索引1
- 小于等于2的元素有3个，因此元素2的最后位置是索引2
- 小于等于3的元素有5个，因此元素3的最后位置是索引4
- 小于等于4的元素有5个，因此元素4的最后位置是索引4（实际没有元素4）
- 小于等于5的元素有8个，因此元素5的最后位置是索引7
- 小于等于6的元素有10个，因此元素6的最后位置是索引9

 5、构建排序结果

1. 创建一个与原数组同样大小的临时数组`temp`
2. ==**从后向前**==遍历原数组（确保排序稳定性）
3. 对于每个元素，根据累加计数数组确定其在排序后的位置
4. 每放置一个元素，==对应的计数值减1==
   最终得到排序结果：`{ 1, 1, 2, 3, 3, 5, 5, 5, 6, 6 }`
5. 将临时数组`temp`中的结果复制回原数组`arr`，完成排序


  > [!note] 为什么要从后向前？
> 为了保持排序的稳定性，稳定性意味着排序前后，两个相同值的元素相对顺序不变。例如，`arr[6] = 5; arr[7]= 5;`，经过排序后，这两个元素不会改变原有顺序。（以两个学生身高相同名字不同举例）

【 归纳总结】

1、计数排序是一种非比较排序算法，将元素作为索引进行统计，所以==排序元素只能是自然数==。

2、计数排序适用于数据范围较小的整数排序，待排序元素之间==不能相差太大==，否则会降低排序效率。

3、计数排序的时间复杂度为O(n+k)，其中n是数组长度，k是数据范围。当k较小时，计数排序可以达到线性时间复杂度，非常高效。

  

### 二、编程实现：

```cpp
#include <iostream>
using namespace std;

void CountingSimple(int a[], int n) {
    // 1. 找出序列的最大值
    int max = a[0];
    for(int i = 1; i < n; i++) {
        if(a[i] > max) max = a[i];
    }
    
    // 2. 创建计数数组(0到max)
    
    int* count_arr = new int[max + 1]();  // 初始化为0
    
    // 3. 统计每个元素出现的次数
    for(int i = 0; i < n; i++) {
        count_arr[a[i]]++;
    }
    
    // 4. 累加计数
    for(int i = 1; i <= max; i++) {
        count_arr[i] += count_arr[i-1];
    }
    
    // 5. 创建结果数组
    int* temp = new int[n];
    
    // 6. 从后向前遍历原数组(保证稳定性)
    for(int i = n - 1; i >= 0; i--) {
        temp[count_arr[a[i]] - 1] = a[i];
        count_arr[a[i]]--;
    }
    
    // 7. 复制回原数组
    for(int i = 0; i < n; i++) {
        a[i] = temp[i];
    }
    
    // 8. 释放内存
    delete[] count_arr;
    delete[] temp;
}

int main() {
    int a[10] = {1, 2, 43, 4, 5, 6, 8, 19, 7, 10};
    // 使用计数排序
    CountingSimple(a, 10);
    
    // 打印结果
    for(int i = 0; i < 10; i++) cout << a[i] << ' ';
    cout << endl;
    return 0;
}

```

## 性能分析
  
> 平均时间复杂度：O(n + k)  
> 最佳时间复杂度：O(n + k)  
> 最差时间复杂度：O(n + k)  
> 空间复杂度：O(n + k)

当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n + k)。。在实际工作中，当k=O(n)时，我们一般会采用计数排序，这时的运行时间为O(n)。

计数排序需要两个额外的数组（计数数组count、暂存数组temp）用来对元素进行计数和保存排序的输出结果，所以空间复杂度为O(k+n)。

计数排序的一个重要性质是它是稳定的：具有相同值的元素在输出数组中的相对次序与它们在输入数组中的相对次序是相同的。也就是说，对两个相同的数来说，==在输入数组中先出现的数，在输出数组中也位于前面。==

计数排序的稳定性很重要的一个原因是：计数排序经常会被用于基数排序算法的一个子过程。我们将在后面文章中介绍，为了使基数排序能够正确运行，计数排序必须是稳定的。
  

## 算法优化


有如下整数：1001，1007，1005，1001，1007，1005，1008。
再比如对一群人按身高排序： 158，164，162，172，168，170，165，158，172，164，166，164

【 思考 】

1、若使用计数排序算法对其排序，会存在什么问题？
2、如果有问题，应该如何优化？

  

【 思路点拨 】

上面一组整数，虽然两两之间相差不大，但是需要==消耗较大的计数数组给较少元素排序==。明明只有很少一段数字，却要开辟一块巨大的内存空间作为计数数组。性能开销很大，非常不划算。

为了降低计数数组的开销，不再使用”==最大元素+1==“作为数组长度，改用（ ==最大元素-最小元素+1==）作为数组长度。

在统计待排序元素出现的次数时，先将==待排序元素减去最小元素==，然后统计差值出现的次数。

在存入原数组的时候，先将索引号加上最小元素，然后再存入原数组。

  

【 示例程序 】

```cpp
#include <iostream>
using namespace std;

void Counting(int a[], int n) {
    // 找出序列的最大值和最小值，以确定区间和偏移量
    int max = a[0];
    int min = a[0];
    for(int i = 1; i < n; i++) {
        max = max >= a[i] ? max : a[i];
        min = min <= a[i] ? min : a[i];
    }
    
    // 序列区间范围
    int d = max - min + 1;
    
    // 声明计数数组，开辟空间
    // 使用动态分配并初始化为0，()的作用是将它初始化为0
    int* count_arr = new int[d]();  
    
    // 遍历原始数组，计数
    // 计数数组的索引代表序列的每个数，索引下存储的值代表这个数出现的次数
    for(int i = 0; i < n; i++) {  // 遍历原始数组应该是n而不是d
        int idx = a[i] - min;  // idx指向序列的每个数
        count_arr[idx]++;
    }
    
    // 累加计数，使count_arr[i]表示小于等于i+min的元素个数（或理解为元素i的最后一个位置+1）
    // 累加计数可以确定元素的最终位置，实现就地排序
    for(int i = 1; i < d; i++) {
        count_arr[i] += count_arr[i-1];
    }
    
    // 创建临时数组存放排序结果
    int* temp = new int[n];
    
    // 从后向前遍历原数组，保证稳定性
    for(int i = n - 1; i >= 0; i--) {
        // idx指向序列的每个数
        int idx = a[i] - min;
        // 放入对应位置：因为数组索引从0开始，最终位置需要-1
        temp[count_arr[idx] - 1] = a[i];  // 放入对应位置
        count_arr[idx]--;  // 更新计数
    }
    
    // 将排序结果复制回原数组
    for(int i = 0; i < n; i++) {
        a[i] = temp[i];
    }
    
    // 释放动态分配的内存块，包括计数数组和临时数组
    delete[] count_arr;
    delete[] temp;
}

int main() {
    int a[10] = {1, 2, 43, 4, 5, 6, 8, 19, 7, 10};
    // 使用计数排序
    Counting(a, 10);
    
    // 打印结果
    for(int i = 0; i < 10; i++) cout << a[i] << ' ';
    cout << endl;
    return 0;
}
```


  


  




  