
我们将线性的数据结构称为线性表，线性表在计算机内存中有顺序表（数组）和链表两种实现方式。

其实我之前在知乎上回答过这个问题，回答内容大概是按照如下类型来刷数组-> 链表-> 哈希表->字符串->栈与队列->树->回溯->贪心->动态规划->图论->高级数据结构，再从简单刷起，做了几个类型题目之后，再慢慢做中等题目、困难题目。

# 链表
链表是一种通过==指针串联在一起的线性结构==，每一个节点由两部分组成，一个是数据域一个是指针域，指针域存放指向下一个节点或上一个节点的指针），形成一条链式的数据结构。


链表的入口节点称为链表的头节点，一般用`head`表示。
链表的尾部节点的指针域一般来说是置空的。



![[Pasted image 20250617171313.png]]

## 链表的存储方式
数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。

链表是通过==指针域的指针链接在内存中各个节点==。

所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。

> 如图所示，链表pics起始节点为2，终止节点为7，各个节点分布在不同的内存空间上，通过指针（地址）串联在一起。

![[Pasted image 20250618110121.png]]


## 链表的类型

### 单链表
单链表就是上图所示的链表形态。
此链表中每个结点由两部分构成：元素自身信息即数据域(用`data`表示)，指向直接后继元素位置的信息称为“指针域”(用`next`表示)。整个链表由一个称为外指针/头结点指针`head`指出，以表明链表的首地址，当链表为空时，`head`为`nullptr`。用线性链表存储线性表时，数据元素间的逻辑关系通过指针反映出来。

int a = 5;
单链表结构的代码如下：
```cpp
struct ListNode{
	int data;
	ListNode *next;
	ListNode(int x): data(x), next(nullptr){}
};
ListNode ls(5)
cout<< ls.data; //5 
```
### 双链表

双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。
双向链表有循环线性和非循环线性，也可根据需要在链表前设置头结点list。
双链表 既可以向前查询也可以向后查询。

![[Pasted image 20250617172011.png]]

双链表结构的代码如下：
```cpp
struct ListNode{
	int data;
	ListNode *prev;
	ListNode *next;
	// 构造函数ListNode
	ListNode(int x): val(x), prev(nullptr),next(nullptr){}
};
```

### 循环链表

链表最后一个链结点的指针指向链表的第1个链结点，整个链表形成一个环，从表中任意结点出发均可找到表中其他结点。

## 链表的操作

### 删除某个节点

![[Pasted image 20250617175538.png]]

只要将C节点的next指针 指向E节点就可以了。
```cpp
// 设置指针指向链表C节点
ListNode* ptr = head-> next;
// 让C.next指向E
ptr->next = ptr->next->next;
```
那有同学说了，D节点不是依然==存留在内存里==么？只不过是没有在这个链表里而已。

是这样的，所以在C++里最好是再==手动释放这个D节点==，释放这块内存。
```cpp
delete d;
```
其他语言例如Java、Python，拥有自己的内存回收机制，就不用自己手动释放了。

### 添加链表节点

![[Pasted image 20250618110748.png]]
```cpp
// 创建F节点
ListNode *F = new ListNode(9);
// 指向C节点，开始操作
ListNode *ptr = head->next;
// 将F的next指针指向C的下一个节点D
F->next = ptr->next;
// C节点next指向F
ptr->next = F;
```
可以看到，链表的删除和添加元素操作都是复杂度为==O(1)==的操作，也不会影响到其他节点。对比一下，数组进行同类操作则需要O(n)的时间复杂度。
### 查找特定节点

链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。因此链表无法随机访问任意元素，查找任一结点都需要进行==复杂度为`O(n)`的顺序查找==过程。

所以，要是想处理第5个节点，那么链表需要从头节点head一路查过去到第四个节点，通过next指针完成删除操作，查找的时间复杂度是`O(n)`。


### 反转链表
[[力扣 热题100系列#206 反转链表]]
```cpp
// 反转(head,tail)左开右闭，区间的节点。返回新的头节点
ListNode* reverse(ListNode* head, ListNode* tail){
    // 让尾部成为头节点
	ListNode* prev = tail;
	while(head != tail){
	    // 暂存下一个，指针转向，前一个移到当前的，当前的移到下一个
		ListNode* temp = head->next;
		head->next = prev;
		prev = head;
		head = temp;
	}
	// 反转过后尾在前
	return prev;
}
```


### 性能分析

链表和数组的性能对比。

|       | 插入/删除时间复杂度 | 查询时间复杂度 | 适用场景            |
| ----- | ---------- | ------- | --------------- |
| 数组/序列 | O(n)       | O(1)    | 数据量固定，经常查询，较少增删 |
| 链表    | O(1)       | O(n)    | 数量量多变，经常增删，较少查询 |
可以见到，数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。
链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。

## 练习

0 删除链表特定值的元素：

# 栈
## 栈的概念
栈（stack）是只能在是一种只允许==在表的一端进行插入和删除操作==的线性表。

想一想货架堆积物品，先堆进来的压在底下，随后一件一件往上堆。取走时，只能从上面一件一件取。堆和取都在顶部进行，底部一般是不动的。栈的名字来源，正是古代货栈的货物堆积和取出形态。

栈就是一种类似货架堆积物品的数据结构，进行删除和插入的一端称栈顶（Top），另一端称栈底（Bottom）。插入一般称为==进栈(PUSH)==，删除则称为==退栈(POP)==。当表中没有任何数据元素时，称之为 **「空栈」**。
![[Pasted image 20250620233102.png]]
简单来说，栈是一种 **「后进先出（Last In First Out）」** 的线性表，简称为 **「LIFO 结构」**。

我们可以从两个方面来解释一下栈的定义：

- 第一个方面是 **「线性表」**。
  栈首先是一个线性表，栈中元素具有==前驱后继的线性关系==。栈中元素按照 `a1​,a2​,...,an`​ 的次序依次进栈。栈顶元素为` an​`。

- 第二个方面是 **「后进先出原则」**。
  根据栈的定义，每次删除的总是栈中当前的栈顶元素，即最后进入栈的元素。而在进栈时，最先进入栈的元素一定在栈底，最后进入栈的元素一定在栈顶。也就是说，元素进入栈或者退出退栈是按照「后进先出（Last In First Out）」的原则进行的。
## 栈的存储结构
一个栈可以用定长为n的数组s来表示，用一个栈指针 top指向栈顶。若top=0,表示
栈空，top=n则栈满。进栈时top加1,退栈时top减1,当top<0时为下溢，栈指针在运算中永远指向栈顶。
![[Pasted image 20250620233318.png]]


## 栈的基本操作

栈有两种基本操作：**「插入操作」** 和 **「删除操作」**。
- 栈的插入操作又称为「入栈」或者「进栈」。
- 栈的删除操作又称为「出栈」或者「退栈」。

### 入栈(PUSH)算法
1. 若栈顶`top>=n`时，则给出上溢出（Upper Overflow）信息，作出错处理(进栈前首先检查栈是否已满，满则溢出；不满则进行2)
2. `top++`(栈指针加1,指向进栈地址)
3. `s[top]=x`，结束(x为新进栈的元素)
### 出栈(POP)算法
1. 若top<=0，则给出下溢出（Lower Overflow）信息，作出错处理(退栈前先检查是否已为空栈，空则下溢；不空则进行2);
2. `x=s[top]`，(退栈后的元素赋给x);
3. `top--`，结束(栈指针减1,指向栈顶)。
```cpp
#define n 100 // 预先指定栈的容量
//入栈
int s[n];

void push(int s[],int *top,int x){ 
	if(*top==n){
		printf("overflow"); // 上溢出
	}
	else{
		*top++;
		s[*top]= x;
	}
}
//出栈
void pop(int s[],int *y,int *top) {
	if(*top==0){
		printf("underflow");
	}

	else{
		*y=s[*top];
		*top--;
	}
}
```

对于出栈运算中的“下溢”,程序中仅给出了一个标志信息，而在实际应用中，下溢作为
控制程序转移的判断标志，是十分有用的。对于入栈运算中的“上溢”,则是一种致命错误，将使程序无法继续运行，所以要设法避免。
## 栈的应用

### 前中后缀表达式
[【数据结构】后缀（逆波兰）表达式的计算以及中缀转后缀的方法-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/2457936)
中缀表达式（Infix Expression）是我们日常书写数学表达式时最常用的形式，比如：

```
A + B * C
```

其中运算符（如 `+`, `*`）位于操作数（如 `A`, `B`, `C`）之间，因此称为​**​中缀表达式​**​。

但在计算机中，为了更方便地计算表达式的值，通常会将中缀表达式转换为​**​前缀表达式（波兰表示法，Polish Notation）​**​或​**​后缀表达式（逆波兰表示法，Reverse Polish Notation）​**​，因为它们​**​不需要括号就能明确运算顺序​**​，且易于用栈来求值。

---

#### 中缀转后缀表达式（逆波兰表示法）

规则：
使用一个栈来存放运算符，遍历中缀表达式，按照以下规则处理：
​​1 如果是操作数（数字或变量），直接输出。​​
​​2 如果是左括号 `(`，入栈。​​
​​3 如果是右括号 `)`，则将栈中的运算符依次弹出并输出，直到遇到左括号，左括号弹出但不输出。​​
​​4 如果是运算符：​
    1 若栈为空，或栈顶为左括号` (`，直接入栈。
    2 否则，比较当前运算符与栈顶运算符的优先级：
        1 如果当前运算符优先级 ​​高于​​ 栈顶运算符，则 ​​入栈​​；
        2 如果当前运算符优先级 ​​小于或等于​​ 栈顶运算符，则将栈顶运算符弹出并输出，然后继续比较新的栈顶运算符，直到可以入栈为止。
​​5 表达式遍历完后，将栈中剩余的运算符全部弹出并输出。​​
    

优先级（一般情况）：
- `*``/`：高优先级
- `+``-`：低优先级
- `(`：特殊，入栈时优先级最低，但入栈后优先级最高（只有遇到 `)`才弹出）

示例：中缀表达式 `A + B * C`转后缀
步骤：

|当前字符|栈状态（栈底→栈顶）|输出结果|说明|
|---|---|---|---|
|A|空|A|操作数，直接输出|
|+|+|A|运算符，栈空，入栈|
|B|+|A B|操作数，直接输出|
|*|+ *|A B|* 优先级 > +，入栈|
|C|+ *|A B C|操作数，直接输出|
|（结束）||A B C * +|弹出 *，再弹出 +，输出|

✅ ​**​后缀表达式：`A B C * +`​**​



#### 中缀转前缀表达式（波兰表示法）

规则：
前缀表达式是​**​运算符在操作数之前​**​，比如 `+ A * B C`。转换方法类似于后缀，但需要​**​从右往左扫描中缀表达式​**​，具体步骤如下：
1. ​**​从右向左扫描中缀表达式。​**​
2. ​**​如果是操作数，直接输出。​**​
3. ​**​如果是右括号 `)`，入栈。​**​
4. ​**​如果是左括号 `(`，则将栈中的运算符依次弹出并输出，直到遇到右括号，右括号弹出但不输出。​**​
5. ​**​如果是运算符：​**​
    - 若栈为空，或栈顶为右括号 `)`，直接入栈。
    - 否则，比较当前运算符与栈顶运算符的优先级：
        - 如果当前运算符优先级 ​**​高于​**​ 栈顶运算符，则 ​**​入栈​**​；
        - 如果当前运算符优先级 ​**​小于或等于​**​ 栈顶运算符，则将栈顶运算符弹出并输出，继续比较，直到可以入栈。
6. ​**​扫描结束后，将栈中剩余运算符全部弹出并输出。​**
7. ​**​最后将得到的结果顺序反转，即为前缀表达式。​**​

> 或者更直观的方法是：​**​先将中缀表达式反转（包括括号也要对应反转，即 `(`↔ `)`），然后按照类似后缀的方式处理，最后再将结果反转回来。​**​



示例：中缀表达式 `A + B * C`转前缀
方法一：标准步骤（从右往左扫描）
我们以 `A + B * C`为例，从右向左扫描：
原始表达式：`A + B * C`
从右往左：`C * B + A`
步骤：

|当前字符|栈状态|输出结果|说明|
|---|---|---|---|
|C|空|C|操作数，直接输出|
|*|*|C|运算符，入栈|
|B|*|C B|操作数，直接输出|
|+|+|C B *|+ 优先级 <= *（栈顶），弹出 * 输出；然后 + 入栈|
|A|+|C B * A|操作数，直接输出|
|（结束）||+ A * B C|弹出 +，最终得到前缀表达式|

但更直观的方法是：

方法二：反转中缀 → 转后缀 → 再反转（推荐）
1. ​**​原中缀表达式：​**​ `A + B * C`
2. ​**​反转表达式并翻转括号：​**​ `C * B + A`（暂时无括号，如果有要互换 `(`和 `)`）
3. ​**​按中缀转后缀的方法处理这个反转后的表达式：​**​
    - 相当于在反向中求后缀，最后再整体反转即得前缀
    按 `C * B + A`处理（从左到右，当做普通中缀转后缀）：
    - C → 输出 C
    - - → 入栈
    - B → 输出 B
    - - → * 优先级 > +，弹出 * 输出，然后 + 入栈
            
    - A → 输出 A
        
    - 栈中剩下 +，弹出
        
    
    → 后缀为：`C B * A +`
    
4. ​**​将这个后缀反转，即得前缀表达式：`+ A * B C`​**​
    

✅ ​**​前缀表达式：`+ A * B C`​**​

#### 总结

|目标|方法简述|示例（中缀：A + B * C）|
|---|---|---|
|​**​后缀表达式（逆波兰）​**​|从左到右扫描，用栈处理运算符，优先级高的先入栈，遇到右括号弹出到左括号，最后弹出栈内剩余运算符|结果：`A B C * +`|
|​**​前缀表达式（波兰）​**​|方法1：从右往左扫描处理（类似后缀规则）  <br>方法2（推荐）：反转中缀 → 按中缀转后缀处理 → 反转结果|结果：`+ A * B C`|

---



### 递归

#### 递归函数

### 深度优先搜索

#### dfs
# 队列
## 队列的概念
队列（Queue）是限定在一端进行插入，另一端进行删除的特殊线性表。

就像排队买东西，排在前面的人买完东西后离开队伍(删除),而后来的人总是排在队伍末尾(插人)。通常把队列的删除和插人分别称为出队和入队。

所有需要进队的数据项，只能从队尾进入，队列中的数据项只能从队头离去。由于总是先入队的元素先出队(先排队的人先买完东西)。
我们把队列中允许插入的一端称为 **「队尾（rear）」**；把允许删除的另一端称为 **「队头（front）」**。当表中没有任何数据元素时，称之为 **「空队」**。
![[Pasted image 20250620234435.png]]
简单来说，队列是一种 **「先进先出（First In First Out）」** 的线性表，简称为 **「FIFO 结构」**。

我们可以从两个方面来解释一下队列的定义：

- 第一个方面是 **「线性表」**。
  队列首先是一个线性表，队列中元素具有前驱后继的线性关系。队列中元素按照 `a1,a2,...,an`的次序依次入队。队头元素为 `a1​`，队尾元素为 `an​`。

- 第二个方面是 **「先进先出原则」**。
  根据队列的定义，最先进入队列的元素在队头，最后进入队列的元素在队尾。每次从队列中删除的总是队头元素，即最先进入队列的元素。也就是说，元素进入队列或者退出队列是按照「先进先出（First In First Out）」的原则进行的。

## 队列的存储结构

队列可以用数组`Q[m+1]`来存储，数组的上界m即是队列所容许的最大容量。在队列
的运算中需设两个指针：

- `front`：队头指针，指向实际队头元素的前一个位置；
- `rear`：队尾指针，指向实际队尾元素所在的位置。

一般情况下，两个指针的初值设为0。这时队列为空，没有元素。

## 队列的基本操作

队列有两种基本操作：**「插入操作」** 和 **「删除操作」**。

- 队列的插入操作又称为「入队」。
- 队列的删除操作又称为「出队」。


图1(a)画出了一个由6个元素构成的队列，数组定义`Q[11]`。`Q(i)i=3,4,5,6,7,8`，头指针 `front=2`,尾指针 `rear=8`。

队列中拥有的元素个数为`L = rear - front`,现要让排头的元素出队，则需将头指针加1，即`front++`。
这时头指针向上移动一个位置，指向`Q(3)`,表示`Q(3)`已出队，见图1(b)。
如果想让一个新元素入队，则需尾指针向上移动一个位置，即`tail++`,这时`Q(9)`入队，
见图1(c)。
### “假溢出”问题
当队尾已经处在最上面时，即`rear=10`，见图1(d)。此时如果还要执行入队操作，则要发生“上溢出（Overflow）”。
然而，实际上队列中还有三个空位置，所以这种溢出称为==“假溢出（Pseudo Overflow）”==。
![[Pasted image 20250620235926.png]]

克服假溢出的方法有两种。一种是将队列中的所有元素均向低地址区移动，显然这种方法很浪费时间；

另一种更好的办法是使用循环队列：==将数组存储区看成是一个首尾相接的环形区域==。当存放到n地址后，下一个地址就“翻转”为1。利用数学中的求模运算，使得空间得以重复利用，这样就解决了问题。

在结构上采用这种技巧来存储的队列称为==循环队列==，见图2。
![[Pasted image 20250621000549.png]]
循环队列的入队算法如下：
1. `tail++`；
2. 若`tail=n+1`，则`tail=1`；
3. 若`head=tail`，尾指针与头指针重合，表示元素已装满队列，则作上溢出错处理；
4. 否则，`Q(tail)=x`，结束(x为新入队元素)。

在进行插入操作时，如果队列的第 n个位置被占用之后，只要队列前面还有可用空间，新的元素加入队列时就可以从第 1 个位置开始继续插入。

我们约定：size 为循环队列的最大元素个数。队头指针 front 指向队头元素所在位置的前一个位置，而队尾指针 rear 指向队尾元素所在位置。则：

1. **插入元素（入队）时**：队尾指针循环前进 1个位置，即 `rear=(rear+1)%size`。
2. **删除元素（出队）时**：队头指针循环前进 1个位置，即 `front=(front+1)%size`。

这样，“假溢出”问题就得到了解决。
