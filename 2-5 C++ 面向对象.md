# 结构体
在实际问题中，一组数据往往具有不同的数据类型。例如，老师统计学生信息时，我们需要记录每一位同学的的姓名、年龄、性别、身份证号码。这些信息分别要用整型、字符型、字符串型来记录。为了解决问题，C++语言给出了另一种构造数据类型——“结构体”，它在数据存储方面相当于其他高级语言中的记录，但它有着面向对象的优势。

结构体是一种用户自定义的数据类型，用于将==不同类型的数据（如int、float、char、vector）组织到统一的类型==之下，适用于对关系紧密，逻辑相关、具有相同或不同类型的数据进行处理。


## 定义
在C++ 中使用 **struct** 语句定义结构体（structure）。格式如下：
```cpp
struct type_name {
	member_type1 member_name1;
	member_type2 member_name2;
	member_type3 member_name3;
	.
	.
} object_names;
```
**type_name** 是结构体类型的名称，`member_type1 member_name1` 是标准的变量定义，比如 `int i;` 或者 `float f;` 或者其他有效的变量定义。在结构定义的末尾，最后一个分号之前，可以选择声明一个或多个结构体变量。
## 使用
例如：下面是声明一个结构体类型 **Books**，变量为 **book**：
```cpp
struct Books
{
   string title;
   string author;
   string subject;
   int   book_id;
} book1;

// 指定书的名字，作者，科目，书号
book1.title = "CSP-J竞赛宝典";
book1.author = "张三";
book1.subject = "少儿编程";
book1.book_id = 12345;

// 声明一本新书
Books book2;
book2.title = "Python入门";
book2.author = "李四";
book2.subject = "少儿编程";
book2.book_id = 16789;
```

结构体作为一个由用户（也就是你自己）定义的类型，可以和C++中的类型（int、char、string、vector）一样，作为函数参数传递。
传递参数的方法和其他变量或指针是类似的。
```cpp
#include <iostream>
#include <string>

using namespace std;

 // 声明一个结构体类型 Books 
struct Books
{
   string title;
   string author;
   string subject;
   int book_id;
};
using namespace std;
// 打印一本书的信息
void printBook( struct Books book )
{
   cout << "书标题 : " << book.title <<endl;
   cout << "书作者 : " << book.author <<endl;
   cout << "书类目 : " << book.subject <<endl;
   cout << "书 ID : " << book.book_id <<endl;
}
 

 
int main( )
{
   Books book1;        // 定义结构体类型 Books 的变量 Book1
   Books book2;        // 定义结构体类型 Books 的变量 Book2
 
	// 指定书1的名字，作者，科目，书号
	book1.title = "CSP-J竞赛宝典";
	book1.author = "张三";
	book1.subject = "少儿编程";
	book1.book_id = 12345;
	
	// 指定书2的名字，作者，科目，书号
	book2.title = "Python入门";
	book2.author = "李四";
	book2.subject = "少儿编程";
	book2.book_id = 16789;
 
   // 输出 Book1 信息
   printBook( book1 );
   // 输出 Book2 信息
   printBook( book2 );
   
   return 0;
}
```

与C语言中的结构体相比，==C++中的结构体支持定义成员函数==，成员函数是对一个结构体变量以及其中的数据元素进行操作的函数，也叫方法。

# 共用体
共用体（union)是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。

和结构体类似，共用体也用于将组织不同类型的数据。
但共用体和结构体的最大的区别在于，一个带有多个数据成员的共用体，==任何时候只能有一个数据成员带有值==，换句话说，这些数据成员共享同一块内存位置。

共用体提供了一种==使用相同的内存位置==的有效方式。
## 定义
使用union语句定义共用体的定义方式与结构体类似。
```cpp
union union_name{
	member_type1 member_name1;
	member_type2 member_name2;
	member_type3 member_name3;
	.
	.
} object_names;
```
## 使用
共用体的使用和结构体类似。
```cpp
union Data
{
   int i;
   float f;
   char  str[20];
} data;
```
`Data` 类型的变量可以存储一个整数、一个浮点数，或者一个字符串。这意味着一个变量（相同的内存位置）可以存储多个多种类型的数据。您可以根据需要在一个共用体内使用任何内置的或者用户自定义的数据类型。

共用体占用的内存空间取决于==共用体中最大的成员体积==。例如，在上面的实例中，`Data `将==占用 20 个字节的内存空间==，因为在各个成员中，字符串`str`所占用的空间是最大的。下面的实例将显示上面的共用体占用的总内存大小：
```cpp
#include <iostream>
 
union Data
{
   int i;
   float f;
   char str[20];
};
 
int main( )
{
   Data data;        
   printf( "变量data占用的内存空间: %d\n", sizeof(data));
 
   return 0;
}
```

## 共用体的特性

```cpp
#include <iostream>
#include <cstring>
union Data
{
   int i;
   float f;
   char  str[20];
};
 
int main()
{
   Data data;        
 
   data.i = 10;
   data.f = 220.5;
   strcpy( data.str, "C Programming");
 
   printf( "data.i : %d\n", data.i);
   printf( "data.f : %f\n", data.f);
   printf( "data.str : %s\n", data.str);
 
   return 0;
}
```
这段代码的运行结果如下：
```plain
data.i : 1917853763
data.f : 4122360580327794860452759994368.000000
data.str : C Programming
```
在这里，我们可以看到共用体的 **i** 和 **f** 成员的值被损坏了，读取的值不是原来赋给它的值。
因为共用体同一时刻只允许一个变量有值，`data.str`是最后赋值的，覆盖了前面赋值的`data.f`，`data.f`在`data.i`之后赋值，覆盖了`data.i`。
也就是说`data.str`最后占用了内存位置，能够完好输出。其他两个变量都被覆盖，得到的是一个损坏的值。


# 类

C++在C语言的基础上增加了面向对象编程。==类（class）==是C++的核心特性，通常被称为==用户定义的类型==，其包含了数据表示和用于处理数据的方法。类中的数据和方法都称为类的成员。

【例】下面是一个盒子类，描述一个盒子的长宽高，以及计算盒子容积的方法
```cpp
#include <iostream>
#include <string>
using namespace std;

struct Box(//方法一
	public: //public是类型修饰符，具体意义见“类访问修饰符”
		// 类的数据成员，也就是类中的变量
		double length; //长度
		double width; //宽度
		double height;//高度
		//类的成员函数，也就是类中的函数，或者叫“方法”
		double getVolume(){ 
			return length*width*height;
		}
};

int main() {
	// 创建一个盒子对象xiaohezi
    Box xiaohezi = Box();
	xiaohezi.length = 5;
	xiaohezi.width = 3;
	xiaohezi.height = 4;
	cout << xiaohezi.getVolume() << endl;
    return 0;
}
```


## 类的成员

类的成员包括数据成员和成员函数（方法）。
### 类成员的访问权限
数据封装是面向对象编程的一个重要特点，它防止==函数直接访问类类型的内部成员==。类成员的访问限制是通过在类主体内部对各个区域标记 `public`、`private`、`protected` 来指定的。

关键字 `public`、`private`、`protected` 称为访问修饰符。

一个类可以有多个 `public`、`protected` 或 `private` 标记区域。每个标记区域在下一个标记区域开始之前或者在遇到类主体结束右括号之前都是有效的。成员和类的默认访问修饰符是 `private`。

#### 公有（public）成员
在程序中，**公有**成员在类的外部是可访问的。您可以不使用任何成员函数来设置和获取公有变量的值，如下所示：


#### 私有（private）成员
**私有**成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有==类自己==和==友元函数==可以访问私有成员。

默认情况下，类的所有成员都是私有的。例如在下面的类中，**width** 是一个私有成员，这意味着，如果您没有使用任何访问修饰符，类的成员将被假定为私有成员：

实际操作中，我们一般会在私有区域定义数据，在公有区域定义相关的函数，以便在类的外部也可以通过公有函数访问私有成员，如下所示：


#### 保护（protected）成员
**保护**成员变量或函数与私有成员十分相似，但有一点不同，保护成员在==派生类（即子类）==中是可访问的。

在下一个章节中，您将学习到派生类和继承的知识。现在您可以看到下面的实例中，我们从父类 **Box** 派生了一个子类 **smallBox**。

下面的实例与前面的实例类似，在这里 **width** 成员可被派生类 smallBox 的任何成员函数访问。

### 访问权限的继承方式

有public, protected, private三种继承方式，它们相应地改变了基类成员的访问属性。

`public`：
public继承的访问权限保持了原来基类的访问权限。基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private

`protected`：
基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private。


`private`：
基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private

但无论哪种继承方式，上面两点都没有改变：

- 1.private 成员只能被本类成员（类内）和友元访问，不能被派生类访问；
- 2.protected 成员可以被派生类访问。

### this指针
在 C++ 中，每一个对象都能通过 **this** 指针来访问自己的地址。**this** 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。

友元函数没有 **this** 指针，因为友元不是类的成员。只有成员函数才有 **this** 指针。

下面的实例有助于更好地理解 this 指针的概念：
```cpp
#include <iostream>

using namespace std;

class Box
{
   public:
      // 构造函数定义
      Box(double l=2.0, double b=2.0, double h=2.0)
      {
         cout <<"Constructor called." << endl;
         length = l;
         breadth = b;
         height = h;
      }
      double Volume()
      {
         return length * breadth * height;
      }
      int compare(Box box)
      {
         return this->Volume() > box.Volume();
      }
   private:
      double length;     // Length of a box
      double breadth;    // Breadth of a box
      double height;     // Height of a box
};

int main(void)
{
   Box Box1(3.3, 1.2, 1.5);    // Declare box1
   Box Box2(8.5, 6.0, 2.0);    // Declare box2

   if(Box1.compare(Box2))
   {
      cout << "Box2 is smaller than Box1" <<endl;
   }
   else
   {
      cout << "Box2 is equal to or larger than Box1" <<endl;
   }
   return 0;
}
```
上面的代码执行结果是：
```cpp
Constructor called.
Constructor called.
Box2 is equal to or larger than Box1
```
### 类的静态成员

#### 静态数据成员
我们可以使用 `static` 关键字来把类成员定义为静态的。当我们声明类的成员为静态时，这意味着无论创建多少个类的对象，静态成员都只有一个副本。

静态成员在==类的所有对象中是共享==的。

如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零。因此，我们不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过==使用范围解析运算符 **::** 来重新声明静态变量==从而对它进行初始化，如下面的实例所示：
`Box`类的静态成员`objectCount`用于统计一共创建了多少个对象。
```cpp
#include <iostream>
using namespace std;

class Box
{
   public:
      static int objectCount;
      // 构造函数定义
      Box(double l=2.0, double b=2.0, double h=2.0)
      {
         cout <<"Constructor called." << endl;
         length = l;
         breadth = b;
         height = h;
         
         // 每次创建对象时增加 1
         objectCount++;
      }
      double Volume()
      {
         return length * breadth * height;
      }
   private:
      double length;     // 长度
      double breadth;    // 宽度
      double height;     // 高度
};

// 初始化类 Box 的静态成员
int Box::objectCount = 0;

int main(void)
{
   Box Box1(3.3, 1.2, 1.5);    // 声明 box1
   Box Box2(8.5, 6.0, 2.0);    // 声明 box2

   // 输出对象的总数
   cout << "Total objects: " << Box::objectCount << endl;

   return 0;
}
```

#### 静态成员函数
如果把函数成员声明为静态的，就可以把函数与类的任何特定对象独立开来。静态成员函数即使在类对象不存在的情况下也能被调用，**静态函数**只要使用类名加范围解析运算符 **::** 就可以访问。

静态成员函数只能访问静态成员数据、其他静态成员函数和类外部的其他函数。

静态成员函数有一个类范围，他们不能访问类的 this 指针。您可以使用静态成员函数来判断类的某些对象是否已被创建。




























### 结构体与类
C语言中有结构体（struct），C++中的struct对C中的struct进行了扩充，它已经不再只是一个包含不同数据类型的数据结构了。

在C++中，==结构体struct基本上和类class是一样的==。它们都可以拥有成员函数，实现继承，实现多态。

结构体和类的主要区别：他们的**默认继承访问权限**不同。struct是public的，class是private的。  

## 类的创建和删除

### 构造函数
类的**构造函数**是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。

构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。


## 友元
友元（Friend）C++的一个特性，它允许一个非成员函数（即不属于任何类的普通函数）直接访问某个类的 ​​私有（`private`）​​ 和 ​​保护（`protected`）​​ 成员。通过将某个函数声明为类的“友元”，可以赋予该函数特殊权限，==突破封装的限制来直接操作类的私有数据==。

友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。

尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。因此友元函数没有`this`指针。

如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 **friend**，如下所示：

> 简单来说，友元是一个类外部的函数，但可以访问类的所有成员，包括私有（private）成员和保护（protected）成员。

### 使用场景
1. 非成员运算符重载，
2. 两个类或者多个函数需要共享数据：有时候，两个类之间关系紧密，或者某个工具函数需要访问多个类的私有数据，可以将这些函数声明为相应类的友元，从而实现数据的共享与操作，同时保持代码的封装性（只在必要的地方开口）。
3. 提高某些工作函数效率：需要一个工具函数频繁访问类成员，如果总是通过公有接口访问，效率较低，这时可以设为友元函数，直接访问内部私有成员。

