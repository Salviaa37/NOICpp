程序=算法+数据结构

## 算法的概念

### 定义与特征

算法就是==解决问题的操作步骤==。一个算法必须满足以下5个重要的特征：

1.有穷性：执行有穷步，在有穷的时间内完成。
2.确切性：每一条指令必须有确切的含义，不会产生歧义。在任何条件下算法只有唯一的一条执行路径。
3.可行性：算法中的操作可以通过执行有限次来实现。
4.输入：一个算法有0个或者多个输入。
5.输出：一个算法有1个或者多个输出。

### 算法的复杂度

对于同一个问题，我们可以设计并使用不同的算法来解决。不同算法有好有坏，一个算法质量的优劣将影响到算法乃至程序运行的效率。因此，我们需要进行算法分析，选择合适的算法和改进算法。

一个算法的评价主要从两个维度来考虑，一个是时间复杂度，另一个空间复杂度。

#### 空间复杂度
空间复杂度指执行算法所需占用的内存空间。
算法执行时所需的存储空间包括程序本身占用的空间、输入数据占用的空间以及算法执行时所需空间。

算法在时间的高效性和空间的高效性之间通常是矛盾的，所以一般会取一个平衡点。
通常假设==程序运行在足够大的内存空间==中，所以研究更多的是算法的时间复杂度。


#### 时间复杂度🌟

**定义与表示**
指算法执行时所需消耗时间，通常用算法执行次数来衡量，记作$T(n)=O(f(n))$,其中$f(n)$是==算法执行次数的函数==。用大写$O()$来体现算法时间复杂度的记法，称之为大O记法。

**计算步骤**
(1)找出基本操作确定规模$n$。通常取最深层循环内的语句所描述的操作作为基本操作。
(2)计算执行次数的函数$f(n)$并求出$T(n)=O(f(n))$。$O(f(n))$是取$f(n)$中$n$增长最快的那项系数为$1$的形式。

【例1】 计算下面函数的时间复杂度
```cpp
void fundemo(int n){
	int i=1,j=100;
	while(i<n){
		i+=2;
		++j;
	}
}
```
答案：O(n)

## 入门算法
### 枚举算法

[视频讲解枚举算法](https://www.bilibili.com/video/BV1X14y1o7pt/?spm_id_from=333.337.search-card.all.click&vd_source=574e0a38261401341cd391f17b73fdad)
你有一盘钥匙，但你不记得哪一把钥匙可以打开储物柜的门，所以你只能一把一把去尝试。这就是枚举（Enumerate）。

枚举算法（Enumeration Algorithm）：也称为穷举算法，指的是按照问题本身的性质，==逐一列举出该问题所有可能的解与目标状态进行比较==，以得出满足问题要求的解。
在列举的过程中，既不能遗漏也不能重复。
#### 核心思想
枚举算法的核心思想是：通过列举问题的所有状态，将它们逐一与目标状态进行比较，从而得到满足条件的解。

由于枚举算法要通过列举问题的所有状态来得到满足条件的解，因此，在问题规模变大时，其效率一般是比较低的。但是枚举算法也有自己特有的优点：
1. 多数情况下==容易编程实现==，也容易调试
2. 建立在考察大量状态、甚至是穷举所有状态的基础上，所以==算法的正确性==比较容易证明。
所以，枚举算法通常用于求==解问题规模比较小==的问题，或者作为求解问题的一个子算法出现，通过枚举一些信息并进行保存，而这些消息的有无对主算法效率的高低有着较大影响。

#### 解题思路

枚举算法是设计最简单、最基本的搜索算法。是我们在遇到问题时，最应该优先考虑的算法。

采用枚举算法解题的一般思路如下：

1 确定==枚举对象==，设未知数
2 划定==具体的枚举范围==
3 设立判断条件，检查判断条件设立
4 逐一枚举可能的情况，并验证是否是问题的解。
5 考虑提高枚举算法的效率。

可以从下面几个方面考虑提高算法的效率：
- 抓住问题状态的本质，尽可能==缩小问题状态空间的大小==。
- 加强约束条件，==缩小枚举范围==。
- 根据某些问题特有的性质，例如对称性等，===避免对本质相同的状态重复求解===。
#### 应用场景
下面举个著名的例子：「百钱买百鸡问题」。

> **百钱买百鸡问题**：鸡翁一，值钱五；鸡母一，值钱三；鸡雏三，值钱一；百钱买百鸡，则鸡翁、鸡母、鸡雏各几何？

翻译一下，意思就是：公鸡一只5钱，母鸡一只3钱，小鸡3只1钱。现在我们用 100 块钱买了 100 只鸡，问公鸡、母鸡、小鸡各买了多少只？

下面我们根据算法的一般思路来解决一下这道题。

1.确定==枚举对象==：枚举对象为公鸡、母鸡、小鸡的只数，那么我们可以用变量 x、y、z 分别来代表公鸡、母鸡、小鸡的只数。

2.确定==枚举范围==：因为总共买了 100 只鸡，所以 `0≤x,y,z≤100`，则 x、y、z 的枚举范围为 `[0,100]`。

3.确定==判断条件==：根据题意，我们可以列出两个方程式：`5*x+3*y+z/3​=100`，`x+y+z=100`。在枚举 x、y、z 的过程中，我们可以根据这两个方程式来判断是否当前状态是否满足题意。

4.逐一枚举可能的情况，并验证是否是问题的解。
根据枚举对象、枚举范围和判断条件，我们可以顺利写出对应的代码。
```CPP
void chicken100(){
	for(int x = 0; x <= 100; x++){  //
		for(int y = 0; y <= 100; y++){
			for(int z = 0; z <= 100; z++){ 
				if( z%3==0 && 5*x+3*y+z/3 == 100 && x+y+z == 100){
               printf("公鸡%d只,母鸡%d只,小鸡%d只 \n\t",x,y,z);
            }
			}
		}
	}
}
```
5.优化
1. 在上面的代码中，我们枚举了 x、y、z，但其实根据方程式 `x+y+z=100`，得知：z 可以通过`z=100−x−y `而得到，这样我们就不用再枚举 z 了。
2. 在上面的代码中，对 x、y 的枚举范围是` [0,100]`，但其实如果所有钱用来买公鸡，最多只能买 20 只，同理，全用来买母鸡，最多只能买 33 只。所以对 x 的枚举范围可改为`[0,20]`，yy 的枚举范围可改为 `[0,33]`。
```cpp
void chicken100(){
	for(int x = 0; x <= 20; x++){  
		for(int y = 0; y <= 33; y++){
			if( z%3==0 && 
			5*x+3*y+z/3 == 100 ){
               printf("公鸡%d只,母鸡%d只,小鸡%d只 \n\t",x,y,z);
            }
		}
	}
}
```

因为枚举法实现足够简单，所以在遇到问题时，我们往往可以先通过枚举算法尝试解决问题，然后在此基础上，再去考虑其他优化方法和解题思路。
### 模拟法

生活中，当我们想了解一个复杂系统的运行情况时，常常会建立一个小模型来模拟它的行为。比如，想知道排队买票需要多长时间，我们可以模拟顾客到达、购票、离开的整个过程。这就是模拟（Simulation）。

模拟法（Simulation Method）：指的是用程序模仿现实世界中系统、过程或事件的运行逻辑，通过逐步执行真实的操作步骤来观察系统行为并得到结果的算法。
在模拟的过程中，我们需要严格按照题目描述的规则和流程进行。

#### 核心思想
模拟法的核心思想是：==按照题目描述的过程和规则，用代码一步一步地重现真实的操作流程==，通过观察模拟过程中的状态变化来得到最终结果。

由于模拟法需要严格按照题目描述的步骤进行，因此在问题规模较大时，其效率可能不是最优的。但是模拟法也有自己独特的优点：
1. ==思路直观易懂==，符合人类的思维习惯
2. 实现过程清晰，便于理解和调试
3. 适用范围广，几乎所有能够描述清楚的过程都可以用模拟法解决
4. 正确性容易保证，只要严格按照题目要求实现即可

所以，模拟法通常用于求解过程描述清晰、规则明确的问题，特别是那些难以用数学公式直接计算的复杂过程。

#### 解题思路

模拟法是最贴近现实的算法思想。当我们遇到描述某个具体过程的问题时，模拟法往往是首选的解决方案。

采用模拟法解题的一般思路如下：

1. **理解过程**：仔细分析题目，理解需要模拟的过程和规则
2. **设计状态**：确定需要维护的状态变量和数据结构
3. **划分步骤**：将复杂的过程分解为简单的基本操作
4. **编写代码**：按照过程的时间顺序或操作顺序逐步实现

考虑提高模拟算法的效率：
我们可以从下面几个方面考虑提高算法的效率：

- 优化数据结构，选择合适的存储方式
- 减少不必要的计算和重复操作
- 合理设计循环结构，避免无效的状态检查
- 适当使用数学方法简化部分模拟步骤

#### 编程建议

模拟题目通常具有码量大、操作多、思路繁复的特点。由于它码量大，经常会出现难以查错的情况，如果在考试中写错是相当浪费时间的。

写模拟题时，遵循以下的建议有可能会提升做题速度：

1. 在动手写代码之前，在草纸上尽可能地写好要实现的流程
2. 在代码中，尽量把每个部分模块化，写成函数、结构体或类
3. 对于一些可能重复用到的概念，可以统一转化，方便处理：如，某题给你"YY-MM-DD 时：分"把它抽取到一个函数，处理成秒，会减少概念混淆
4. 调试时分块调试。模块化的好处就是可以方便的单独调某一部分
5. 写代码的时候一定要思路清晰，不要想到什么写什么，要按照落在纸上的步骤写

实际上，上述步骤在解决其它类型的题目时也是很有帮助的。

#### 应用场景
下面举个经典的例子：「蠕虫(蜗牛）爬井问题」。

> **蠕虫爬井问题**：一只长度不计的蠕虫位于 n 英寸深的井的底部。它每次向上爬 u 英寸，但是必须休息一次才能再次向上爬。在休息的时候，它滑落了 d 英寸。之后它将重复向上爬和休息的过程。蠕虫爬出井口需要至少爬多少次？如果蠕虫爬完后刚好到达井的顶部，我们也认为蠕虫已经爬出井口。

下面我们根据算法的一般思路来解决一下这道题。

1. **理解过程**：蠕虫的行为很简单：向上爬→休息滑落→向上爬→休息滑落……直到爬出井口。我们需要模拟这个重复的过程。

2. **设计状态**：我们需要维护蠕虫当前的位置 `dist` 和已经爬行的次数 `time`。

3. **划分步骤**：每一轮包含两个基本操作：
   - 向上爬 u 英寸，次数加1
   - 如果还没爬出井口，则滑落 d 英寸

4. **编写代码**：用循环来重复上述过程，直到蠕虫爬出井口。

根据模拟对象、状态变量和操作步骤，我们可以顺利写出对应的代码。

```cpp
#include <iostream>
using namespace std;

void wormClimb() {
    // n是井的深度，u是向上爬的距离，d是向下滑落的距离
    int n = 0, u = 0, d = 0;
    cin >> u >> d >> n;
    
    int time = 0, dist = 0;  // time记录爬行次数，dist记录当前位置
    
    while (true) {  // 用循环来模拟爬井过程
        dist += u;   // 向上爬
        time++;      // 爬行次数加1
        
        if (dist >= n) break;  // 如果已经爬出井口，退出循环
        
        dist -= d;   // 休息时滑落
    }
    
    cout << time << endl;  // 输出爬行次数
}
```

因为模拟法思路直观、实现简单，所以在遇到过程描述清晰的问题时，我们往往可以先通过模拟法尝试解决问题，然后在此基础上，再去考虑其他优化方法和解题思路。
