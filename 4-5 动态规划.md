动态规划（Dynamic Programming，简称DP）是一种重要的算法设计思想，用于解决具有重叠子问题和最优子结构性质的问题。

[不是我催... 以后大家学动态规划，都得要看这个视频。_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1m9EUzLEB4/?vd_source=574e0a38261401341cd391f17b73fdad)

## 引入

[\[IOI1994\] 数字三角形](https://www.luogu.com.cn/problem/P1216)
给定一个 $r$ 行的数字三角形（ $r≤1000$ ），需要找到一条从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到当前点左下方的点或右下方的点。

```plain
        7 
      3   8 
    8   1   0 
  2   7   4   4 
4   5   2   6   5
```

在上面这个例子中，最优路径是 $7→3→8→7→5$ 。

最简单粗暴的思路是尝试所有的路径。因为路径条数是 $O(2r)$ 级别的，这样的做法无法接受。

注意到这样一个事实，一条最优的路径，它的每一步决策都是最优的。

以例题里提到的最优路径为例，只考虑前四步 $7→3→8→7$ ，不存在一条从最顶端到 $4$ 行第 $2$ 个数的权值更大的路径。

而对于每一个点，它的下一步决策只有两种：往左下角或者往右下角（如果存在）。因此只需要记==录当前点的最大权值==，用这个最大权值执行下一步决策，来更新后续点的最大权值。

这样做还有一个好处：我们成功缩小了问题的规模，==将一个问题分成了多个规模更小的问题==。要想得到从顶端到第 $r$ 行的最优方案，只需要知道从顶端到第 $r−1$ 行的最优方案的信息就可以了。

这时候还存在一个问题：子问题间重叠的部分会有很多，同一个子问题可能会被重复访问多次，效率还是不高。解决这个问题的方法是==把每个子问题的解存储下来，通过记忆化的方式限制访问顺序==，确保每个子问题只被访问一次。

上面就是动态规划的一些基本思路。下面将会更系统地介绍动态规划的思想。


# 核心思想

动态规划的核心思想是：将复杂的原问题分解为更简单的子问题，通过不断解决子问题，最终解决原问题；在解决子问题的同时，存储子问题的解，以避免重复的解决步骤。

# 基本特征

能用动态规划解决的问题，需要满足三个条件（基本特征）：最优子结构，无后效性和子问题重叠。

### 最优子结构

具有最优子结构也可能是适合用==贪心==的方法求解。

注意要确保我们考察了最优解中用到的所有子问题。

1. 证明问题最优解的第一个组成部分是做出一个选择；
2. 对于一个给定问题，在其可能的第一步选择中，假定你已经知道哪种选择才会得到最优解。你现在并不关心这种选择具体是如何得到的，只是假定已经知道了这种选择；
3. 给定可获得的最优解的选择后，确定这次选择会产生哪些子问题，以及如何最好地刻画子问题空间；
4. 证明作为构成原问题最优解的组成部分，每个子问题的解就是它本身的最优解。方法是反证法，考虑加入某个子问题的解不是其自身的最优解，那么就可以从原问题的解中用该子问题的最优解替换掉当前的非最优解，从而得到原问题的一个更优的解，从而与原问题最优解的假设矛盾。

要保持子问题空间尽量简单，只在必要时扩展。

最优子结构的不同体现在两个方面：

1. 原问题的最优解中涉及多少个子问题；
2. 确定最优解使用哪些子问题时，需要考察多少种选择。

我们可以画出一张动态规划的子问题图，子问题图中每个定点对应一个子问题，而需要考察的选择对应关联至子问题顶点的边。

### 无后效性

已经求解的子问题，不会再受到后续决策的影响。换句话说，上面的子问题图不会有环。

### 子问题重叠

如果有大量的重叠子问题，我们可以用空间将这些子问题的解存储下来，避免重复求解相同的子问题，从而提升效率。

综上所述：
1. 最优子结构：问题的最优解包含子问题的最优解
2. 无后效性：子问题的解一旦确定，不会再改变。也就是说，子问题只受到前面已解决子问题的影响
3. 重叠子问题：递归过程中会反复求解相同的子问题

# 解题思路

对于一个能用动态规划解决的问题，一般采用如下思路解决：

1. 将原问题划分为若干 **阶段** ，每个阶段对应若干个子问题，提取这些子问题的特征（称之为 **状态** ）；
2. 寻找每一个状态的可能 **决策** ，或者说是各状态间的相互转移方式（用数学的语言描述就是 **状态转移方程** ）。
3. 按顺序求解每一个阶段的问题。

如果用图论的思想理解，我们建立一个 [有向无环图](https://oi-wiki.org/graph/dag/) ，每个状态对应图上一个节点，决策对应节点间的连边。这样问题就转变为了一个在 DAG 上寻找最长（短）路的问题（参见： [DAG 上的 DP](https://oi-wiki.org/dp/dag/) ）。


具体来说，
1. 定义状态：确定用什么变量表示子问题，如数字三角形中，”使得每一个节点路径的加权和最大“表示子问题。
2. 状态转移方程：找出状态之间的递推关系。由前面的状态如何推出下一个状态。数字三角形中，当前节点的路径加权和仅由左上角或者右上角决定。
3. 初始化：确定边界条件，路径只有一条
4. 计算顺序：确定状态的计算顺序，按照计算顺序求解子问题，从已计算的状态中得到最终答案。

# 经典应用
###  斐波那契数列
斐波那契数列：数列由 $f(0)=1,f(1)=2$开始，后面的每一项数字都是前面两项数字的和。也就是：
$$f(n) = \begin{cases} 0 & n = 0 \cr 1 & n = 1 \cr f(n - 2) + f(n - 1) & n > 1 \end{cases}$$
子问题：每个斐波那契数列的值是多少？
状态：第n个数表示其对应的Fibonacci数列的值；
状态递推式子（动态转移方程）：$f(n) = f(n-1)+f(n-2)$
终止条件：$f(0),f(1)$

为了避免重复计算，我们可以使用动态规划中的「状态存储」来处理。

代码：
```cpp
int fibonacci(int n) {
    if (n <= 1) return n;
    
    vector<int> dp(n + 1);
    dp[0] = 0;
    dp[1] = 1;
    
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2];//状态转移
    }
    
    return dp[n];
}
```
时间复杂度为`O(n)`，空间复杂度`O(n)`。


传统上的方法是使用==递归==求解，使用递归时，递归过程树应该是这样的。
![[Pasted image 20250723111815.png]]
从图中可以看出：如果使用传统递归算法计算 $f(5)$ ，需要先计算 $f(3)$ 和 $f(4)$ ，而在计算 $f(4)$ 时还需要计算 $f(3)$ ，这样 $f(3)$ 就进行了多次计算。同理 $f(0)$ 、 $f(1)$ 、 $f(2)$ 都进行了多次计算，从而导致了重复计算问题，时间复杂度高。



### 爬楼梯
描述：假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 11或 2 个台阶。现在给定一个整数 n。
要求：计算出有多少种不同的方法可以爬到楼顶。
```cpp
int climbStairs(int n) {
    if (n <= 2) return n;
    
    vector<int> dp(n + 1);
    dp[1] = 1;
    dp[2] = 2;
    
    for (int i = 3; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2];  // 从第i-1阶爬1步 或 从第i-2阶爬2步
    }
    
    return dp[n];
}
```
爬楼梯和`Fibonacci`数列的原理类似。


### 最长公共子序列

最长公共子序列问题

给定一个长度为 $n$ 的序列 $A$ 和一个 长度为 $m$ 的序列 $B$ （ $n,m≤5000$ ），求出一个最长的序列，使得该序列既是 $A$ 的子序列，也是 $B$ 的子序列。

子序列的定义可以参考 [子序列](https://oi-wiki.org/string/basic/) 。一个简要的例子：字符串 `abcde` 与字符串 `acde` 的公共子序列有 `a` 、 `c` 、 `d` 、 `e` 、 `ac` 、 `ad` 、 `ae` 、 `cd` 、 `ce` 、 `de` 、 `ade` 、 `ace` 、 `cde` 、 `acde` ，最长公共子序列的长度是 4。

设 $f(i,j)$ 表示只考虑 $A$ 的前 $i$ 个元素， $B$ 的前 $j$ 个元素时的最长公共子序列的长度，求这时的最长公共子序列的长度就是 **子问题** 。 $f(i,j)$ 就是我们所说的 **状态** ，则 $f(n,m)$ 是最终要达到的状态，即为所求结果。

对于每个 $f(i,j)$ ，存在三种决策：如果 $Ai=Bj$ ，则可以将它接到公共子序列的末尾；另外两种决策分别是跳过 $Ai$ 或者 $Bj$ 。状态转移方程如下：

$$
f(i,j)=\begin{cases} f(i−1,j−1)+1& A_i=B_j\cr \max(f(i−1,j),f(i,j−1))& A_i≠B_j \end{cases}
$$

可参考 [SourceForge 的 LCS 交互网页](http://lcs-demo.sourceforge.net/) 来更好地理解 LCS 的实现过程。

该做法的时间复杂度为 $O(nm)$ 。


```cpp
int a[MAXN], b[MAXM], f[MAXN][MAXM];

int dp() {
  for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++)
      if (a[i] == b[j])
        f[i][j] = f[i - 1][j - 1] + 1;
      else
        f[i][j] = max(f[i - 1][j], f[i][j - 1]);
  return f[n][m];
}
```


# 动态规划的优势

## 时间复杂度优化
朴素递归斐波那契数列的实现时间复杂度是$O(2^n)$，通过 动态规划：通过存储子问题结果，降低到$O(n)$。

## 空间换时间（状态存储/记忆化搜索）
动态规划通过额外的存储空间来避免重复计算，是典型的"空间换时间"策略。这种优势的具体体现为在很多动态规划问题中，使用记忆化搜索实现。

记忆化搜索是一种通过记录已经遍历过的状态的信息，从而避免对同一状态重复遍历的搜索实现方式。

因为记忆化搜索确保了每个状态只访问一次，它也是一种常见的动态规划实现方式。

例题：
[\[NOIP2005\] 采药](https://www.luogu.com.cn/problem/P1048)
山洞里有 $M$ 株不同的草药，采每一株都需要一些时间 $ti$ ，每一株也有它自身的价值 $vi$ 。给你一段时间 $T$ ，在这段时间里，你可以采到一些草药。让采到的草药的总价值最大。要求$1≤T≤103$ ， $1≤ti,vi,M≤100$。

#### 朴素的 DFS 做法
很容易实现这样一个朴素的搜索做法：在搜索时记录下当前==准备选第几个物品、剩余的时间是多少、已经获得的价值是多少==这三个参数，然后枚举当前物品是否被选，转移到相应的状态。

朴素实现
```cpp
int n, t;
int tcost[103], mget[103];
int ans = 0;

void dfs(int pos, int tleft, int tans) {
  if (tleft < 0) return;
  if (pos == n + 1) {
    ans = max(ans, tans);
    return;
  }
  dfs(pos + 1, tleft, tans);
  dfs(pos + 1, tleft - tcost[pos], tans + mget[pos]);
}

int main() {
  cin >> t >> n;
  for (int i = 1; i <= n; i++) cin >> tcost[i] >> mget[i];
  dfs(1, t, 0);
  cout << ans << endl;
  return 0;
}
```
这种做法的时间复杂度是指数级别的O(2^n)，一定会超出时间。

#### 记忆化搜索
如果我们每查询完一个状态后将该状态的信息存储下来，再次需要访问这个状态就可以直接使用之前计算得到的信息，从而避免重复计算。这充分利用了动态规划中很多问题具有大量重叠子问题的特点，属于用空间换时间的「记忆化」思想。
上面的做法为什么效率低下呢？因为同一个状态会被访问多次。

如果我们每查询完一个状态后将该状态的信息存储下来，再次需要访问这个状态就可以直接使用之前计算得到的信息，从而避免重复计算。这充分利用了动态规划中很多问题具有大量重叠子问题的特点，属于用空间换时间的「记忆化」思想。

具体到本题上，我们在朴素的 DFS 的基础上，增加一个数组 `mem` 来记录每个 `dfs(pos,tleft)` 的返回值。刚开始把 `mem` 中每个值都设成 `-1` （代表没求解过）。每次需要访问一个状态时，如果相应状态的值在 `mem` 中为 `-1` ，则递归访问该状态。否则我们直接使用 `mem` 中已经存储过的值即可。

通过这样的处理，我们确保了每个状态只会被访问一次，因此该算法的的时间复杂度为 $O(TM)$ 。

实现
```cpp
int n, t;
int tcost[103], mget[103];
int mem[103][103];

int dfs(int pos, int tleft) {
  if (mem[pos][tleft] != -1)
    return mem[pos][tleft];  // 已经访问过的状态，直接返回之前记录的值
  if (pos == n + 1) return mem[pos][tleft] = 0;
  int dfs1, dfs2 = -INF;
  dfs1 = dfs(pos + 1, tleft);
  if (tleft >= tcost[pos])
    dfs2 = dfs(pos + 1, tleft - tcost[pos]) + mget[pos];  // 状态转移
  return mem[pos][tleft] = max(dfs1, dfs2);  // 最后将当前状态的值存下来
}

int main() {
  memset(mem, -1, sizeof(mem));
  cin >> t >> n;
  for (int i = 1; i <= n; i++) cin >> tcost[i] >> mget[i];
  cout << dfs(1, t) << endl;
  return 0;
}
```


--- 

# 动态规划的问题分类

## 线性DP
- 斐波那契数列、爬楼梯（见经典例子）
- 最大公共子序列，最长递增子序列(LIS)
- 最大子数组和

## 区间DP
### 定义

区间类动态规划是线性动态规划的扩展，它在分阶段地划分问题时，与阶段中元素出现的顺序和由前一阶段的哪些元素合并而来有很大的关系。

令状态 $f(i,j)$ 表示将下标位置 $i$ 到 $j$ 的所有元素合并能获得的价值的最大值，那么 $f(i,j)=\max\{f(i,k)+f(k+1,j)+cost\}$ ， $cost$ 为将这两组元素合并起来的价值。

### 性质

区间 DP 有以下特点：

**合并** ：即将两个或多个部分进行整合，当然也可以反过来；

**特征** ：能将问题分解为能两两合并的形式；

**求解** ：对整个问题设最优值，枚举合并点，将问题分解为左右两个部分，最后合并两个部分的最优值得到原问题的最优值。

### 解释

#### 例题

[「NOI1995」石子合并](https://loj.ac/problem/10147)
题目大意：在一个环上有 $n$ 个数 $a1,a2,…,an$ ，进行 $n−1$ 次合并操作，每次操作将相邻的两堆合并成一堆，能获得新的一堆中的石子数量的和的得分。你需要最大化你的得分。

需要考虑不在环上，而在一条链上的情况。

令 $f(i,j)$ 表示将区间 $[i,j]$ 内的所有石子合并到一起的最大得分。

写出 **状态转移方程** ： $f(i,j)=max{f(i,k)+f(k+1,j)+∑t=ijat} (i≤k<j)$

令 $sumi$ 表示 $a$ 数组的前缀和，状态转移方程变形为 $f(i,j)=max{f(i,k)+f(k+1,j)+sumj−sumi−1}$ 。

#### 怎样进行状态转移

由于计算 $f(i,j)$ 的值时需要知道所有 $f(i,k)$ 和 $f(k+1,j)$ 的值，而这两个中包含的元素的数量都小于 $f(i,j)$ ，所以我们以 $len=j−i+1$ 作为 DP 的阶段。首先从小到大枚举 $len$ ，然后枚举 $i$ 的值，根据 $len$ 和 $i$ 用公式计算出 $j$ 的值，然后枚举 $k$ ，时间复杂度为 $O(n3)$

#### 怎样处理环

题目中石子围成一个环，而不是一条链，怎么办呢？

**方法一** ：由于石子围成一个环，我们可以枚举分开的位置，将这个环转化成一个链，由于要枚举 $n$ 次，最终的时间复杂度为 $O(n4)$ 。

**方法二** ：我们将这条链延长两倍，变成 $2×n$ 堆，其中第 $i$ 堆与第 $n+i$ 堆相同，用动态规划求解后，取 $f(1,n),f(2,n+1),…,f(n,2n−1)$ 中的最优值，即为最后的答案。时间复杂度 $O(n3)$ 。

#### 实现

```cpp
for (len = 2; len <= n; len++)
  for (i = 1; i <= 2 * n - len; i++) {
    int j = len + i - 1;
    for (k = i; k < j; k++)
      f[i][j] = max(f[i][j], f[i][k] + f[k + 1][j] + sum[j] - sum[i - 1]);
  }
```


- 矩阵链乘法
- 回文串问题

## 背包DP
背包类DP是一种二维的动态规划方法
###  0-1背包
问题描述：

有 n 件物品和一个容量为 W 的背包，每件物品有重量 `w[i]` 和价值 `v[i]`。求在不超过背包容量的前提下可以获得的最大价值。

在上述例题中，由于每个物体只有两种可能的状态（取与不取），对应二进制中的 $0$ 和 $1$ ，这类问题便被称为「0-1 背包问题」。


#### 解释

例题中，已知条件有第 $i$ 个物品的重量 $w_i$ ，价值 $v_i$ ，以及背包的总容量 $W$ 。

往背包中装东西的过程，
设 DP 状态 $f(i,j)$ 为在只能放前 $i$ 个物品的情况下，（剩余）容量为 $j$ 的背包所能达到的最大总价值。

考虑转移。假设当前已经处理好了前 $i−1$ 个物品的所有状态，那么对于第 $i$ 个物品：
当其不放入背包时，背包的剩余容量不变，背包中物品的总价值也不变，故这种情况的最大价值为 $f(i−1,j)$ ；
当其放入背包时，背包的剩余容量会减小 $w_i$ ，背包中物品的总价值会增大 $v_i$ ，故这种情况的最大价值为 $f(i−1,j−w_i)+v_i$ 。


由此可以得出状态转移方程：

$$
f(i,j)=\max(f(i−1,j),f(i−1,j−w_i)+v_i)
$$

再来考虑约束条件。
状态转移时，要考虑题目给出的约束条件，这里我们需要考虑的是背包的容量，只有当要放入的物品重量不超过背包剩余容量时，才可以放入背包中；否则，本次状态转移的最大值应当为放入上一件物品的最大值：
$$ 
f(i,j)= f(i-1,j)
$$


这里如果直接采用二维数组对状态进行记录，会出现大量的重复计算，导致运行超时 MLE。可以考虑改用滚动数组的形式来优化。
```cpp
#include <iostream>
#include <vector>
using namespace std;

int knapsack(int W, vector<int>& weights, vector<int>& values, int n) {
	// 状态存储数组
    vector<vector<int>> dp(n + 1, vector<int>(W + 1, 0));
	// 二维dp，二重循环
    for (int i = 1; i <= n; i++) {
        for (int w = 0; w <= W; w++) {
            if (w >= weights[i - 1]) //注意⚠️：不要让物品超出背包容量
	            // 状态转移方程
                dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1]);
            else
            // 不放入的情况
                dp[i][w] = dp[i - 1][w];
        }
    }

    return dp[n][W];
}

int main() {
    vector<int> weights = {2, 1, 3};
    vector<int> values = {4, 2, 3};
    int W = 4;
    int n = weights.size();

    cout << "最大价值为: " << knapsack(W, weights, values, n) << endl;
    return 0;
}
```
#### 优化（滚动数组）
由于对 $f(i)$ 有影响的只有 $f(i−1)$ ，换句话说，物品是一件一件顺着挑选的，因此可以去掉第一维，直接用 $f(j)$ 来表示处理到当前物品时背包容量为 $j$ 的最大价值，得出以下方程：

$$
f(j)=max(f(j),f(j−w_i)+v_i)
$$
如果不放入，那么最大价值$f$ 就是当前剩余容量$j$时的最大值$f(j)$；
如果放入，那么容量变为$j-w_i$（$w_i$为当前放入的第i件物品），最大值增加$v_i$ 。

务必牢记并理解这个转移方程，因为大部分背包问题的转移方程都是在此基础上推导出来的。

为什么是滚动数组？？

#### 实现
```cpp
int knapsack(int W, vector<int>& weights, vector<int>& values, int n) {
	// 状态存储数组
    vector<int> dp(n + 1);
	// 滚动数组优化，一维dp
    for (int i = 1; i <= n; i++) { // 物品列表循环
        for (int j = W; j >= w[i]; j--) { // 状态转移循环
            if (j >= weights[i]) //注意⚠️：不要让物品超出背包容量
	            // 状态转移方程
                dp[j] = max(dp[j], dp[j - weights[i]] + values[i]);
            else
            // 不放入的情况
                dp[i][w] = dp[i - 1][w];
        }
    }

    return dp[n][W];
}
```



还有一点需要注意的是，很容易写出这样的 错误核心代码 ：

（二维 dp）




---

优化：滚动数组优化（空间优化）
滚动数组优化是一种空间优化方法。


将二维 `dp[i][w]` 优化为一维 `dp[w]`，从大到小遍历容量：

```cpp
for (int i = 0; i < n; i++) {
    for (int w = W; w >= weights[i]; w--) {
        dp[w] = max(dp[w], dp[w - weights[i]] + values[i]);
    }
}
```



### 完全背包

#### 解释

完全背包模型与 0-1 背包类似，与 0-1 背包的区别仅在于一个物品可以选取无限次，而非仅能选取一次。

我们可以借鉴 0-1 背包的思路，进行状态定义：设 $fi,j$ 为只能选前 $i$ 个物品时，容量为 $j$ 的背包可以达到的最大价值。

需要注意的是，虽然定义与 0-1 背包类似，但是其状态转移方程与 0-1 背包并不相同。

#### 过程

可以考虑一个朴素的做法：对于第 $i$ 件物品，枚举其选了多少个来转移。这样做的时间复杂度是 $O(n3)$ 的。

状态转移方程如下：

$$
f(i,j)=\max_{k=0}^{+∞}(f(i−1,j−k×w_i)+v_i×k)
$$

考虑做一个简单的优化。可以发现，对于 $fi,j$ ，只要通过 $fi,j−wi$ 转移就可以了。因此状态转移方程为：

$$
f(i,j)=max(f(i−1,j),f(i,j−w_i)+v_i)
$$

理由是当我们这样转移时， $fi,j−wi$ 已经由 $fi,j−2×wi$ 更新过，那么 $fi,j−wi$ 就是充分考虑了第 $i$ 件物品所选次数后得到的最优结果。换言之，我们通过局部最优子结构的性质重复使用了之前的枚举过程，优化了枚举的复杂度。

与 0-1 背包相同，我们可以将第一维去掉来优化空间复杂度。如果理解了 0-1 背包的优化方式，就不难明白压缩后的循环是正向的（也就是上文中提到的错误优化）。

[「Luogu P1616」疯狂的采药](https://www.luogu.com.cn/problem/P1616)

题意概要：有 $n$ 种物品和一个容量为 $W$ 的背包，每种物品有重量 $wi$ 和价值 $vi$ 两种属性，要求选若干个物品放入背包使背包中物品的总价值最大且背包中物品的总重量不超过背包的容量。




- 多重背包

### 4. 状态机DP
- 股票买卖问题
- 状态转换类问题

### 5. 数位DP
- 数字范围内满足条件的数的个数

## 优化技巧

### 1. 空间优化
很多DP问题可以用滚动数组优化空间复杂度：

```cpp
// 原始版本：O(n)空间
vector<int> dp(n + 1);

// 滚动数组：O(1)空间
int prev2 = 0, prev1 = 1, curr;
for (int i = 2; i <= n; i++) {
    curr = prev1 + prev2;
    prev2 = prev1;
    prev1 = curr;
}
```

### 2. 状态压缩
当状态可以用位运算表示时，可以大大减少空间使用。

## 解题模板

```cpp
// 一维DP
for (int i = 1; i <= n; i++) {
    dp[i] = /* 根据前面的状态计算 */;
}

// 二维DP
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
        dp[i][j] = /* 根据dp[i-1][j], dp[i][j-1]等计算 */;
    }
}
```

动态规划是算法设计中的重要思想，掌握了基本的解题思路和常见模式后，就能解决很多复杂的优化问题。关键是要多练习，培养识别DP问题特征的能力。
## 简单背包类DP


## 简单区间类DP


## 参考
[8.1 动态规划基础 | 算法通关手册（LeetCode）](https://algo.itcharge.cn/08_dynamic_programming/08_01_dynamic_programming_basic/#_1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%80%E4%BB%8B)
[看一遍就理解：动态规划详解](https://mp.weixin.qq.com/s/QG97jNCOOhxDnAeHrosQIw)