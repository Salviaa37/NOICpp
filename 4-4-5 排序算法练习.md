---
Date: 2025-06-06
---

## 工具 

视频动画演示
[合集·数据结构(精美动画演示讲解)-蓝不过海呀个人主页-哔哩哔哩视频](https://space.bilibili.com/401399175/lists/3102780?type=season)

算法可视化工具
[通过动画可视化数据结构和算法- VisuAlgo](https://visualgo.net/zh)

## 习题



【习题 1】成绩名次

给定m（1<m<50）位同学的语文成绩，请问第n（1<=n<=m）名的语文分数是多少？用冒泡排序完成。

【输入】输入两行，第一行输入m和n的值，第二行输入m个整数表示每位同学的语文成绩，用空格分隔。

【输出】输出第n名的语文分数。

【示例输入】

10 3

68 79 90 85 59 97 85 68 92 90

【示例输出】

90

【思路点拨】

将学生的分数存入一维数组中，然后使用冒泡排序对数组内的元素降序排序，输出排序后的第m个元素即可（数组索引从1开始使用）。

【习题1 示例程序】成绩名次

```cpp
# include <bits/stdc++.h>
using namespace std;
int m, n;// 声明m、n两个变量int
a[100]; // 声明一维数组用于存储分数
int main() { cin >> m >> n; 
// 使用for循环输入m位同学的语文分数（整型） 
for (int i = 1; i <= m; i++) cin >> a[i]; 
// 外层for循环控制比较的轮数 
for (int i = 1; i <= m - 1; i++) {  
// 每轮排序都声明一个标识变量flag，默认为false，表示没有交换  
bool flag = false;  // 内层for循环进行两两比较，逆序则交换  
for (int j = 1; j <= m - i; j++) {
if (a[j] < a[j+1]) { // 注意：这里要降序排序！！！ swap(a[j], a[j+1]); flag = true; // 如果有交换操作，将flag设为true}  }  // 如果这一轮没有做任何交换，就停止排序  if (!flag) break; } // 输出第n名的分数（因为数组索引从1开始使用，这里直接使用n即可） cout << a[n] << endl; return 0;}
```

  

  

【习题 2】卖围巾

商店老板进货了一批围巾，这批围巾共两种规格，第一种==短款的长度是128cm，第二种长款的长度是168cm==。老板只知道自己总共进货n条围巾（1<n<100），不知道每种围巾分别进货多少条。老板打算先卖掉m条围巾（1<=m<n），而且从短款围巾开始卖。请问，卖出的第m条围巾是长款的还是短款的？

【输入】输入两行，第一行输入n和m的值，第二行输入n个整数表示每条围巾的长度，用空格分隔。

【输出】输出“长款”或“短款”。

【示例输入】

```
8 5

128 168 128 128 168 168 128 168
```

【示例输出】

长款

【思路点拨】

将围巾的长度存入一维数组中，然后使用冒泡排序对数组内的元素升序排序，输出排序后的第m个元素即可（数组索引从1开始使用）。

注意：输出的时候，需要判断一下围巾的长度，如果围巾长度为128，输出“短款”，否则输出“长款”。

【习题2 示例程序】卖围巾

```cpp
# include <bits/stdc++.h>
using namespace std;
int m, n;// 声明m、n两个变量
int a[100]; // 声明一维数组用于存储围巾长度
int main() { 
	cin >> n >> m; // 使用for循环输入n条围巾的长度（整型） for (int i = 1; i <= n; i++) cin >> a[i]; // 外层for循环控制比较的轮数 for (int i = 1; i <= n - 1; i++) {  // 每轮排序都声明一个标识变量flag，默认为false，表示没有交换  bool flag = false;  // 内层for循环进行两两比较，逆序则交换  for (int j = 1; j <= n - i; j++) {if (a[j] > a[j+1]) { // 注意：这里要升序排序！！！ swap(a[j], a[j+1]); flag = true; // 如果有交换操作，将flag设为true}  }  // 如果这一轮没有做任何交换，就停止排序  if (!flag) break; } // 输出卖出的第m条毛巾的款式（因为数组索引从1开始使用，这里直接使用n即可） if (a[m] == 128) cout << "短款" << endl; else cout << "长款" << endl; return 0;}
```

注意：输出中文如果出现乱码，可以将编辑器的字符编码改成“GB2312”或“GBK”。

  

  
## 习题与解答

  
## 整理试卷(插入排序)

考试结束后，老师将批改好的试卷按照从低分到高分的顺序整理好了。但是，发现抽屉里还有几张试卷没有批改，老师继续改卷打分。请你帮老师将后来打分的试卷按照从低分到高分的顺序插入到已整理好的试卷中。

【输入】4行。第一行是整数n，表示开始批改的试卷的数量；第二行是n个整数，表示已从小到大排好序的试卷；第三行是整数m，表示抽屉里发现的试卷数量；第四行m个乱序整数，表示后来批改的每张试卷的得分。

【输出】从低分到高分依次输出每张试卷的得分，用空格分隔。

【示例输入1】

```plain
7
65 76 82 85 90 93 98 
4
81 68 97 71
```

【示例输出1】

```plain
65 68 71 76 81 82 85 90 93 97 98 
```


【示例输入2】

```plain
2
78 81
5
81 68 97 71 78
```

【示例输出2】

```plain
68 71 78 78 81 81 97
```



【思路点拨 1】

已排序部分是先批改的试卷，未排序部分是从抽屉里拿出来的试卷，可将将这两个部分合成一个列表，执行插入排序的时候，从第一个未排序元素所在的索引开始循环即可。

【示例程序 1】

```cpp
#include <bits/stdc++.h>
using namespace std;
// 声明一个整型数组，用于存放试卷分数
int scores[100];
// 声明已排序和未排序试卷数量n、mint n, m;
// 声明插入排序函数，接收数组、数组长度和起始索引三个参数，无返回值
void insertionSort(int a[], int length, int idx) { 
// 第一个元素已有序，从第idx个元素开始循环 
	for (int i = idx; i < length; i++) {  
		// 将待插入元素临时存入key中  
		int key = a[i];  
		// j为已排序元素的最后一位索引  
		int j = i - 1;  
		// 如果j不小于零且j号元素大于待插入元素，进入循环操作  
		while (j >= 0 && a[j] > key){
			// 将j号元素后移一个位置
			a[j+1] = a[j];
			// 将已排序索引j减1(继续往前比较)
			j--;  
		}  
		// 将待插入元素插入到空出来的位置上  
		a[j+1] = key; 
	}
}
int main() {
	int m = 0, n = 0;
	// 记录已排序试卷的数量n 
	cin >> n; 
	// 按照从小到大的顺序输入n个整数(已排序部分) 
	for (int i = 0; i < n; i ++) {
		cin >> scores[i];
	} 
	// 输入未排序试卷的数量m 
	cin >> m; 
	// 输入m个乱序的整数(未排序部分) 
	for (int i = n; i < n + m; i ++){
		cin >> scores[i];  
	}
	// 调用插入排序函数，对数组scores排序 
	insertionSort(scores, n + m, n); 
	// 使用for循环，输出排序结果 
	for (int i = 0; i < n + m; i++) {  
		cout << scores[i] << " "; 
	} 
	cout << endl; 
	return 0;
}
```

  

【思路点拨 2】

对于未排序试卷，可以一张一张地插入到已排序好的试卷中。

【示例程序 2】

```cpp
# include <bits/stdc++.h>using namespace std;
// 声明一个整型数组，用于存放试卷分数int scores[100];// 声明已排序和未排序试卷数量n、mint n, m;
// 声明插入函数，接收数组、已排序最一个元素的索引和待插入元素，无返回值void insertion(int a[], int j, int key) { // 如果j不小于零且j号元素大于待插入元素，进入循环操作 while (j >= 0 && a[j] > key){  // 将j号元素后移一个位置  a[j+1] = a[j];  // 将已排序索引j减1(继续往前比较)  j--; } // 将待插入元素插入到空出来的位置上 a[j+1] = key;}
int main() { // 输出已排序试卷的数量n cin >> n; // 按照从小到大的顺序输入n个整数(已排序部分) for (int i = 0; i < n; i ++) cin >> scores[i]; // 输入未排序试卷的数量m cin >> m; // 声明已排序元素最后一个索引j和待插入元素key int j, key; // 输入m个乱序的整数(未排序部分) for (int i = 0; i < m; i ++) {  // 计算已排序元素最后一个索引  j = n + i - 1;  // 输入带插入元素  cin >> key;  // 调用插入函数，将当前元素插入到已排序元素中  insertion(scores, j, key); } // 使用fro循环，输出排序结果 for (int i = 0; i < n + m; i++) {  cout << scores[i] << " "; } cout << endl; return 0;}
```

  

  

< 本节课到此结束 >

  