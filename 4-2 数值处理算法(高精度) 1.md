

# 大数加法的编程实现

大数加法是指对超过编程语言基本数据类型表示范围的整数进行加法运算。由于普通整数类型(如int, long)有大小限制，我们需要用字符串或数组来表示大数并进行逐位相加。

# 高精度四则运算

高精度四则运算是指处理超出基本数据类型表示范围的大数运算方法。下面我将详细讲解如何实现高精度运算。

高精度算法是一种模拟法，本质上是对手工计算加减乘除的模拟。

## 高精度运算的必要性

我们注意到，在大多数编程语言中，基本数据类型（如int, long等）有固定的位数限制：

- 32位int（int32，long）最大约21亿，也就是$21*10^8$
- 64位long long（int64）最大约$9×10^{18}$

但是很多情况下计算的数字是超出这个限制的，当数字超过这些限制时，就需要使用高精度运算。

## 表示方法

通常用字符串或数组来表示大数：

1. ​**​字符串表示法​**​：如`"12345678901234567890"`
2. ​**​数组表示法​**​：每位数字单独存储，如`[1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0]`

根据具体的题目要求，选择不同的方式表示大数，这里我们选用数组（C++ vector；Python list）

```cpp
// 高精度整数结构体
struct BigInt {
    std::vector<int> digits;  // 每位存一位数字，低位在前（例如123存为{3,2,1}）
};
// 字符串转 BigInt
BigInt stringToBigInt(const std::string& num) {
    BigInt res;
    for (int i = num.size() - 1; i >= 0; i--) {
        res.digits.push_back(num[i] - '0');
    }
    return res;
}

```
## 四则运算实现

### 1. 高精度加法

​**​算法步骤​**​：

1. 对齐两个数的位数（前面补零）
2. 从最低位开始逐位相加
3. 处理进位
4. 最后反转结果字符串(如果需要)

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

BigInt add(const BigInt& a, const BigInt& b) {
    BigInt res;
    int carry = 0;
    for (int i = 0; i < max(a.digits.size(), b.digits.size()) || carry; ++i) {
		// 对齐位数，使用三元运算符
        int x = (i < a.digits.size() ? a.digits[i] : 0);
        int y = (i < b.digits.size() ? b.digits[i] : 0);
        // 当前位的加和，记得加上进位
        int sum = x + y + carry;
        // 当前位
        res.digits.push_back(sum % 10);
        // 保存向下一位的进位
        carry = sum / 10;
    }
    return res;
}

```

### 2. 高精度减法

​**​算法步骤​**​：

1. 比较两数大小，确保大数减小数
2. 对齐位数
3. 从最低位开始逐位相减
4. 处理借位

```cpp
BigInt subtract(const BigInt& a, const BigInt& b) {
    BigInt res;
    int borrow = 0;
    for (size_t i = 0; i < a.digits.size(); ++i) {
        int x = a.digits[i] - (i < b.digits.size() ? b.digits[i] : 0) - borrow;
        if (x < 0) {
            x += 10;
            borrow = 1;
        } else {
            borrow = 0;
        }
        res.digits.push_back(x);
    }
    // 去除前导 0
    while (res.digits.size() > 1 && res.digits.back() == 0)
        res.digits.pop_back();
    return res;
}

```

### 3. 高精度乘法

​**​算法步骤​**​：

1. 初始化结果数组（长度为len(a)+len(b))
2. 双重循环，逐位相乘
3. 累加到正确位置
4. 处理进位

```cpp
// 定义 BigInt：用 vector<int> 表示大整数，低位在前
struct BigInt {
    std::vector<int> digits;
};

// 高精度乘法：返回 a × b
BigInt multiply(const BigInt& a, const BigInt& b) {
    BigInt res;

    // 初始化结果数组长度为 a.size + b.size
    // 最多不会超过这个长度（比如99×99=9801，占4位）
    res.digits.resize(a.digits.size() + b.digits.size(), 0);

    // 双重循环实现竖式乘法
    for (size_t i = 0; i < a.digits.size(); ++i) {
        for (size_t j = 0; j < b.digits.size(); ++j) {
            // 累加每一位的乘积到对应的位置（低位相加）
            res.digits[i + j] += a.digits[i] * b.digits[j];
        }
    }

    // 处理进位：从低位往高位遍历
    int carry = 0;
    for (size_t i = 0; i < res.digits.size(); ++i) {
        res.digits[i] += carry;            // 加上上一步的进位
        carry = res.digits[i] / 10;        // 计算当前位产生的进位
        res.digits[i] %= 10;               // 当前位只保留个位
    }
	// 
    // 移除高位多余的前导 0（但至少保留一位0）,因为resize会多出来0
    while (res.digits.size() > 1 && res.digits.back() == 0) {
        res.digits.pop_back();
    }
    return res;
}

```

### 4. 高精度除法

除法是最复杂的运算，通常实现为：

1. 高精度除以低精度（除数在基本数据类型范围内）
2. 高精度除以高精度（更复杂）

​**​高精度除以低精度示例​**​：

算法步骤：
1. 初始化结果数组（长度为被除数长度）。
2. 从高位到低位进行除法（模拟手算）。
	1. 1. 初始化一个余数 `remainder = 0`
	2. 结果商初始化为与 A 相同长度的数组（或者 `vector<int>`）
	3. 从最高位（`a.digits.size()-1`）到最低位（0）：
	    a. 拼接当前位：`current = remainder * 10 + a.digits[i]`
	    b. 商的当前位 = `current / b`
	    c. 更新 `remainder = current % b`
3. 去除商中的前导零（高位0）
4. 返回结果（商 + 余数）
```cpp
// 高精度整数结构体
struct BigInt {
    std::vector<int> digits; // 存储大整数，每位一个数字，低位在前
};

// 高精度除法：BigInt 除以 int，返回 商(BigInt) 和 余数(int)
std::pair<BigInt, int> divide(const BigInt& a, int b) {
    BigInt quotient;                         // 商的结果
    quotient.digits.resize(a.digits.size()); // 初始与 a 位数一样

    int remainder = 0;  // 当前余数，初始为 0

    // 从高位（a.digits.size()-1）向低位遍历
    for (int i = a.digits.size() - 1; i >= 0; --i) {
        int current = remainder * 10 + a.digits[i]; // 模拟将上一余数向下一位扩展
        quotient.digits[i] = current / b;           // 当前位的商
        remainder = current % b;                    // 更新余数
    }

    // 移除商中的前导0（高位多余的0）
    while (quotient.digits.size() > 1 && quotient.digits.back() == 0)
        quotient.digits.pop_back();

    return {quotient, remainder}; // 返回 商 和 余数
}

```

### 输出
```cpp
void printBigInt(const BigInt& a) {
    for (int i = a.digits.size() - 1; i >= 0; --i)
        std::cout << a.digits[i];
    std::cout << std::endl;
}
```



# 快速幂
快速幂

一个常见的考点是做幂运算an，即n个a相乘。

n如果太小，当然没什么意思。所以这个考点的n极大，例如n=1015。

如果直接乘n次，肯定会超时。另外，由于an极大，一般需要取模再输出。

用下面的例题说明快速幂的编程。

例题：快速幂

https://www.lanqiao.cn/problems/1514/learning/

问题描述：给你三个整数a，n，m，求an mod m。

输入：输入只有一行三个整数，分别代表a，n，m。0≤a, b<231，a+b>0，2≤p<231。

输出：输出an mod m=s，其中a，n，m分别为题目给定的值，s为运算结果。

题解：
方法1：基于分治的快速幂

容易想到一种很快的办法：先算a2，然后再算平方(a2)2，再继续平方((a2)2)2，...总共只需要算O(log2n)次，就得到了an。当n=1015时，log2n ≈ 50，计算量极小。不过这里的n需要是2的幂，如果不是2的幂呢？

下面先用分治法实现。分治法是一种“从宏观到微观”的处理方法。在快速幂这个问题中，把规模为n的大问题分解成两个完全一样的规模为n/2的子问题，子问题再继续分解，直到最后n=1，此时直接返回a即可。

下面是an % m的分治法代码。

注意代码中”%m”的取模操作，如果不取模会导致溢出。

#include<bits/stdc++.h>
using namespace std;
typedef long long ll;     //用long long，比int的范围大
ll fastPow(ll b, ll p,ll k){  //b^n % m
    if(p == 0)   return 1; //特判 a^0 = 1
    if(p == 1)   return b % k;
    ll t = fastPow(b, n/2, k);   //分治
    if(p%2 == 1) return (t % k * t % k) * b % k; //奇数个a
    else    return t % k * t % k ; //偶数个a
}
int main(){
    ll b,p,k; cin>>b>>p>>k;
    cout<<fastPow(b,p,k);
    return 0;
}
读者可以用n=7来模拟代码的计算过程，了解它是如何处理n的，特别是n为奇数的情况。

这个代码已经很不错了，不过，标准的快速幂有更好的方法，用位运算实现。位运算实现快速幂的效率和分治法的效率一样，都是O(log2n)的。

方法2、基于位运算的快速幂

基于位运算的快速幂，用到了二进制数的性质，二进制数每一位的权值按2的倍数递增。下面以a11为例说明如何用倍增法做快速幂。

（1）幂次与二进制的关系。把a11分解成幂a8、a2、a1的乘积：a11 = a8+2+1 = a8 × a2 × a1。其中a1、a2、a4、a8...的幂次都是2的倍数，所有的幂ai都是倍乘关系，可以逐级递推，在代码中用 a *= a实现。

（2）幂次用二进制分解。如何把11分解为8+2+1？利用数的二进制的特征，n = 1110 = 10112 = 23+21+20 = 8+2+1，只需要把n按二进制逐位处理就可以了。

（3）如何跳过那些没有的幂次？例如1011需要跳过a4。做个判断即可，用二进制的位运算实现，用到了n & 1和n >>= 1这两个位运算。

n & 1：取n的最后一位，并且判断这一位是否需要跳过。

n >>= 1：把n右移一位，目的是把刚处理过的n的最后一位去掉。

以n = 10112为例，步骤如下：

n = 1011，计算n & 1得1，最后一位是1，对应 a1。n >>= 1，右移一位，更新n=101。

n = 101，计算n & 1得1，最后一位是1，对应 a2。n >>= 1，更新n=10。

n = 10，计算n & 1得0，最后一位是0，跳过a4。n >>= 1，更新n=1。

n = 1，计算n & 1得1，最后一位是1，对应a8。n >>= 1，更新n=0，结束。

下面是快速幂的代码。

#include<bits/stdc++.h>
using namespace std;
typedef long long ll;   //用long long，比int的范围大
ll fastPow(ll a, ll n, ll m){
    ll ans = 1;
    a %= m;    //能在一定程度上防止下面的a*a越界
    while(n) {
        if(n & 1)   ans = (ans*a) % m; //取模
        a = (a*a) % m;   //取模
        n >>= 1;
    }
    return ans;
}
int main(){
    ll a,n,m;  cin>>a>>n>>m;   //m是模
    cout<<fastPow(a,n,m);
    return 0;
}
例题：小数第n位

https://www.lanqiao.cn/problems/116/learning/

问题描述：我们知道，整数做除法时，有时得到有限小数，有时得到无限循环小数。如果我们把有限小数的末尾加上无限多个0，它们就有了统一的形式。

本题的任务是：在上面的约定下，求整数除法小数点后的第n位开始的3位数。

输入：一行三个整数：a，b，n，用空格分开。a 是被除数，b 是除数，n 是所求的小数后位置。1 ≤ a, b, n ≤ 109。

输出：一行 3 位数字，表示：a除以b，小数后第n位开始的3位数字。

题解：

本题的n很大，显然用暴力法无法求解。本题和快速幂有关系？

为了找到求解方法，下面分析除法计算过程，下面演示181除以7的竖式过程。

图片
开始计算小数点后面的商时，实际上是连续求余，即余数乘以10然后再对除数求余。例如计算到41÷7，商5余6；接着从6×10开始，计算60÷7，商8余4；......等等。

设当前余数是x，x<b。例如上面图中的x = 6。

接着做除法，余数是x’ = 10x mod b，商是y’ = 10x/b。例如上图中，x’ = 4，y’ = 8。

继续做除法，余数是x’’ = 10x’ mod b，商是y’’ = 10x’/b。例如上图中，x’’ = 5，y’’ = 5。

连续做n次这个操作，第n次开始得到的3个y就是答案。

结论是：第n-1次的余数是xn-1 = 10n-1x mod b，第n次的商是yn=10xn-1/b。

xn-1 = 10n-1x mod b就是快速幂取模。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll fastPow(ll a, ll n, ll m){
    ll ans = 1;
    a %= m;
    while(n) {
        if(n & 1)   ans = (ans*a) % m;
        a = (a*a) % m;
        n >>= 1;
    }
    return ans;
}
int main(){
    ll a, b, n;     cin >> a >> b>> n;
    ll x = a * fastPow(10, n - 1, b) % b;
    cout << 10 * x / b;
    x = 10 * x % b;
    cout << 10 * x / b;
    x = 10 * x % b;
    cout << 10 * x / b;
    return 0;
}
```



## 优化技巧

1. ​**​分治乘法​**​：Karatsuba算法或FFT乘法可以优化大数乘法
2. ​**​预处理​**​：对于频繁使用的运算可以预处理存储中间结果
3. ​**​压位存储​**​：每位不止存储0-9，可以存储更大的数（如0-9999）减少运算次数
